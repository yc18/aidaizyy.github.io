<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yunyao Zhang - 张云尧</title>
  <subtitle>会有一天肆无忌惮地桀骜不驯</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://aidaiz.com/"/>
  <updated>2017-05-08T16:40:35.000Z</updated>
  <id>http://aidaiz.com/</id>
  
  <author>
    <name>Yunyao Zhang（张云尧）</name>
    <email>aidaizyy@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Open vSwitch的OpenFlow和QOS</title>
    <link href="http://aidaiz.com/openvswitch-qos/"/>
    <id>http://aidaiz.com/openvswitch-qos/</id>
    <published>2016-11-24T06:41:03.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>OpenFlow协议是一种网络通信协议，属于数据链路层，可以控制几换几或者路由器的转发平面（forwarding plane)，借此改变网络数据包所走的网络路径。<br>Open vSwitch支持OpenFlow协议，就可以控制数据包的走向，还可以修改源目的地址，支持QOS（Quality of Service）等。<br>本文主要介绍Open vSwitch配置OpenFlow协议以及对QOS的支持。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/openvswitch-qos" target="_blank" rel="external">Open vSwitch的OpenFlow和QOS</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x61;&#x69;&#100;&#x61;&#105;&#x7a;&#x79;&#121;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;">&#x61;&#x69;&#100;&#x61;&#105;&#x7a;&#x79;&#121;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2016-12-26</a></strong></p>
<h2 id="OpenFlow基本应用"><a href="#OpenFlow基本应用" class="headerlink" title="OpenFlow基本应用"></a>OpenFlow基本应用</h2><p>这里有两篇参考文章，已经写得非常详细了：</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/cloud/library/1401_zhaoyi_openswitch" target="_blank" rel="external">《基于Open vSwitch的OpenFlow实践》</a></li>
<li><a href="https://github.com/openvswitch/ovs/blob/master/Documentation/tutorials/ovs-advanced.rst" target="_blank" rel="external">Open vSwitch Advanced Features</a></li>
</ul>
<p>交换机包括一个或多个流表，流表中的条目主要包括数据包要匹配的信息，匹配成功后要执行的操作和统计信息三部分。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ovs-vsctl add-br br0</div><div class="line">ovs-vsctl add-port br0 p0 -- <span class="built_in">set</span> interface p0 <span class="built_in">type</span>=internal</div><div class="line">ovs-vsctl add-port br0 eth0</div></pre></td></tr></table></figure>
<p>创建网桥br0，并添加虚拟端口p0和以太网端口eth0。<br>再对br0进行网络配置，使其能上外网，并将p0 up。（参考上一篇博文<a href="http://aidaiz.com/openvswitch-build">《Open vSwitch安装与使用》</a>。）</p>
<p><code>ovs-ofctl</code>是OpenFlow相关命令，详细参考<code>man ovs-ofctl</code>。<br><code>ovs-ofctl show br0</code>命令是显示交换机br0的端口信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$ ovs-ofctl show br0</div><div class="line">FPT_FEATURES_REPLY (xid=0x2): dpid:00000025909765b0</div><div class="line">n_tables:254, n_buffers:256</div><div class="line">capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS ARP_MATCH_IP</div><div class="line">actions: output enqueue set_vlan_vid set_vlan_pcp strip_vlan mod_dl_src mod_dl_dst mod_nw_src mod_nw_dst mod_nw_tos mod_tp_src mod_tp_dst</div><div class="line"> 1(eth0): addr:00:25:90:97:65:b0</div><div class="line">     config:     0</div><div class="line">     state:      0</div><div class="line">     current:    1GB-FD COPPER AUTO_NEG</div><div class="line">     advertised: 10MB-HD 10MB-FD 100MB-HD 100MB-FD 1GB-FD COPPER AUTO_NEG AUTO_PAUSE</div><div class="line">     supported:  10MB-HD 10MB-FD 100MB-HD 100MB-FD 1GB-FD COPPER AUTO_NEG</div><div class="line">     speed: 1000 Mbps now, 1000 Mbps max</div><div class="line"> 2(p0): addr:d2:ca:93:d4:d5:0b</div><div class="line">     config:     0</div><div class="line">     state:      0</div><div class="line">     speed: 0 Mbps now, 0 Mbps max</div><div class="line"> LOCAL(br0): addr:00:25:90:97:65:b0</div><div class="line">     config:     0</div><div class="line">     state:      0</div><div class="line">     speed: 0 Mbps now, 0 Mbps max</div><div class="line">OFPT_GET_CONFIG_REPLY (xid=0x4): frags=normal miss_send_len=0</div></pre></td></tr></table></figure></p>
<p>dpid后面的字符串表示交换机br0的datapath id。<br>eht0前面的0和p0前面的1表示端口eth0和端口p0的OpenFlow端口的id。<br>其他的还有端口名称，端口状态等。</p>
<p>端口的OpenFlow id也可以修改，用<code>ovs-vsctl set interface p0 ofport_request=id</code>命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ ovs-vsctl <span class="built_in">set</span> interface eth0 ofport_request=100</div><div class="line">$ ovs-vsctl <span class="built_in">set</span> interface p0 ofport_request=101</div><div class="line">$ ovs-ofctl show br0</div><div class="line">OFPT_FEATURES_REPLY (xid=0x2): dpid:00000025909765b0</div><div class="line">n_tables:254, n_buffers:256</div><div class="line">capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS ARP_MATCH_IP</div><div class="line">actions: output enqueue set_vlan_vid set_vlan_pcp strip_vlan mod_dl_src mod_dl_dst mod_nw_src mod_nw_dst mod_nw_tos mod_tp_src mod_tp_dst</div><div class="line"> 100(eth0): addr:00:25:90:97:65:b0</div><div class="line">     config:     0</div><div class="line">     state:      0</div><div class="line">     current:    1GB-FD COPPER AUTO_NEG</div><div class="line">     advertised: 10MB-HD 10MB-FD 100MB-HD 100MB-FD 1GB-FD COPPER AUTO_NEG AUTO_PAUSE</div><div class="line">     supported:  10MB-HD 10MB-FD 100MB-HD 100MB-FD 1GB-FD COPPER AUTO_NEG</div><div class="line">     speed: 1000 Mbps now, 1000 Mbps max</div><div class="line"> 101(p0): addr:fe:07:57:d1:46:f7</div><div class="line">     config:     PORT_DOWN</div><div class="line">     state:      LINK_DOWN</div><div class="line">     speed: 0 Mbps now, 0 Mbps max</div><div class="line"> LOCAL(br0): addr:00:25:90:97:65:b0</div><div class="line">     config:     0</div><div class="line">     state:      0</div><div class="line">     speed: 0 Mbps now, 0 Mbps max</div><div class="line">OFPT_GET_CONFIG_REPLY (xid=0x4): frags=normal miss_send_len=0</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ovs-ofctl add-flow br0 priority,in_port=101,actions=normal</div></pre></td></tr></table></figure>
<p>上面命令在br0上添加了一个流表条目，即一个OpenFlow规则，匹配内容是从端口id为101的端口出来的数据包，匹配成功后的操作为normal，即不做特殊处理。<br>prority表示优先级，prority值越高，优先级越高，其取值区间为0-65535，不显示指定的默认值为32768。<br>注意：OpenFlow规则语句中不能加空格；如果一定要加空格，整个规则语句必须要双引号括起来。比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ovs-ofctl add-flow br0 <span class="string">"priority=10, in_port=101, actions=normal"</span></div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ovs-ofctl add-flow br0 in_port=101,actions=normal</div><div class="line">$ ovs-ofctl dump-flows br0</div><div class="line">NXST_FLOW reply (xid=0x4):</div><div class="line"> cookie=0x0, duration=11.641s, table=0, n_packets=0, n_bytes=0, idle_age=11, priority,in_port=101 actions=NORMAL</div><div class="line"> cookie=0x0, duration=61979.386s, table=0, n_packets=7766539, n_bytes=758342681, idle_age=0, priority=0 actions=NORMAL</div></pre></td></tr></table></figure>
<p><code>ovs-ofctl dump-flows br0</code>命令是查看交换机br0中所有的流表条目。<br>上图中出现了两条规则，第二条是我们创建br0时自动生成的，没有任何特殊操作，目的是为了统计数据包信息。<br>第一条规则，是我们创建的：</p>
<ul>
<li>duration: 该规则存在的时间</li>
<li>table: 属于第0号流表</li>
<li>n_packets: 匹配成功的数据包数量</li>
<li>n_bytes: 匹配成功的数据包总大小</li>
<li>idle_age: 与该规则相关的规则最近一次修改到现在的时间<br>我们设置的流表条目没有做任何处理，意义仅仅是统计数据包信息。<br>因为p0是虚拟端口，很少流过数据包，所以n_packets的值几乎不变。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ping -I p0 www.baidu.com</div></pre></td></tr></table></figure>
</li>
</ul>
<p>指定p0端口去ping外网，一段时间后去执行<code>dump-flows</code>命令，可以看到n_packets的值剧烈增加。</p>
<p>除了<code>in_port</code>之外还有其他的匹配模式，除了<code>normal</code>之外还有其他的匹配成功的操作，具体可参加上面提到的文章<a href="http://www.ibm.com/developerworks/cn/cloud/library/1401_zhaoyi_openswitch" target="_blank" rel="external">《基于Open vSwitch的OpenFlow实践》</a>，还可以参考数据库<a href="http://openvswitch.org/support/dist-docs/ovs-vswitchd.conf.db.5.html" target="_blank" rel="external">ovs-vswitchd.conf.db(5)</a>。</p>
<p>其他相关命令还有：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#查看交换机br0中所有的流表</span></div><div class="line">ovs-ofctl dump-tables br0</div><div class="line"></div><div class="line"><span class="comment">#删除端口id为101的端口上所有的的流表条目</span></div><div class="line">ovs-ofctl del-flows br0 in_port=101</div></pre></td></tr></table></figure></p>
<p>关于OpenFlow的应用不再做更多介绍，可以参考上面列出的两篇文章。</p>
<h2 id="Open-vSwitch的QOS"><a href="#Open-vSwitch的QOS" class="headerlink" title="Open vSwitch的QOS"></a>Open vSwitch的QOS</h2><p>Open vSwitch关于QOS的官方资料，主要在：</p>
<ul>
<li><a href="http://openvswitch.org/support/dist-docs/ovs-vsctl.8.html" target="_blank" rel="external">ovs-vsctl(8)</a></li>
<li><a href="http://openvswitch.org/support/dist-docs/ovs-vswitchd.conf.db.5.html" target="_blank" rel="external">ovs-vswitchd.conf.db(5)</a></li>
<li><a href="https://github.com/openvswitch/ovs/blob/master/Documentation/faq/qos.rst" target="_blank" rel="external">Frequently Asked Questions: Quality of Service (QoS)</a></li>
<li><a href="https://github.com/openvswitch/ovs/blob/master/Documentation/howto/qos.rst" target="_blank" rel="external">《Quality of Service (QoS) Rate Limiting》</a></li>
</ul>
<p>Open vSwitch本身并不具备qos功能，是基于linux的”tc”功能实现的，是已经在linux内核中存在的功能。<br>而Open vSwitch所做的是对其部分支持的tc功能进行配置（因为Open vSwitch不是支持所有的tc功能）。<br>如果Open vSwitch不支持你需要的qos功能，那么可以直接使用linux的”tc”。</p>
<h3 id="策略（Policing）"><a href="#策略（Policing）" class="headerlink" title="策略（Policing）"></a>策略（Policing）</h3><p>在linux的qos中，接收数据包使用的方法叫策略（policing），当速率超过了配置速率，就简单的把数据包丢弃。<br>不通过OpenFlow设置，直接在interface上设置。<br><a href="https://github.com/openvswitch/ovs/blob/master/Documentation/faq/qos.rst" target="_blank" rel="external">Frequently Asked Questions: Quality of Service (QoS)</a> 中有一个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ovs-vsctl <span class="built_in">set</span> interface vif1.0 ingress_policing_rate=10000</div><div class="line">ovs-vsctl <span class="built_in">set</span> interface vif1.0 ingress_policing_burst=8000</div></pre></td></tr></table></figure></p>
<p>上面两行命令，把虚拟端口vif1.0的最大接收速率设置为10000kbps，桶大小设置为8000kb。<br>策略使用了简单的令牌桶（token bucket）算法。<br>我们以一定的速度不断生成令牌，除非令牌桶装满。<br>每接收一个包，需要消耗一个令牌；如果没有令牌了，就会把新到达的包丢弃。<br>（这里用“到达”和“接收”来区别，到达节点的包和其中被接收转发的包。)<br>如果到达包的速度大于令牌的生成速度，那么令牌很快消耗干净，新到达的包只能丢弃，那么接收包的速度很快就降下来，和令牌的生成速度一致。<br>所以接收包的速度依赖于令牌的生成速度，换句话说，不能大于令牌的生成速度，也就是最大接收速率，即<code>ingree_policing_rate</code>的值，单位是kbps。<br>如果到达包的速度小于令牌的生成速度，那么令牌很快堆满令牌桶，这时到达包的速度突然增大，令牌桶中有足够的令牌。这一瞬间可供消耗的令牌有桶中的令牌，也有不断生成的令牌，导致接收包的速度也会突然增大，大于令牌的生成速度，也就是大于我们设置的最大接收速率，称为突发接收速率。<br>这时虽然突发接收速率大于最大接受速率，但是也是有限制的，最多增加的速率（最大突发接收速率减去最大接收速率）依赖于桶的大小，换句话说，增加的吞吐量不能大于桶的大小，毕竟桶中令牌只有这么多（多余的可供消耗的令牌），即<code>ingress_policing_burst</code>的值，单位是kb。<br>在上面的例子中，如果所有包的大小都是1kb，那么最多增加的速率达到8000kbps，最大突发接收速率达到18000kbps。</p>
<p>注意：要实现ingress policing，内核必须支持NET_CLS_BASIC，NET_SCH_INGRESS，和NET_ACT_POLICE等模块，而NET_CLS_POLICE不需要，因为已经过时。</p>
<h3 id="整形（Shaping）"><a href="#整形（Shaping）" class="headerlink" title="整形（Shaping）"></a>整形（Shaping）</h3><p>在linux的qos中，发送数据包使用的方法叫整形（shaping）。<br>与策略的不同之处在于，它使用了队列（queue)，除了丢弃数据包之后，还可以缓存数据包延迟发送，或者调度改变数据包的发送顺序。<br>比策略更加精确和有效。<br><a href="https://github.com/openvswitch/ovs/blob/master/Documentation/faq/qos.rst" target="_blank" rel="external">Frequently Asked Questions: Quality of Service (QoS)</a> 中有一个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ovs-vsctl -- \</div><div class="line">  add-br br0 -- \</div><div class="line">  add-port br0 eth0 -- \</div><div class="line">  add-port br0 vif1.0 -- <span class="built_in">set</span> interface vif1.0 ofport_request=5 -- \</div><div class="line">  add-port br0 vif2.0 -- <span class="built_in">set</span> interface vif2.0 ofport_request=6 -- \</div><div class="line">  <span class="built_in">set</span> port eth0 qos=@newqos -- \</div><div class="line">  --id=@newqos create qos <span class="built_in">type</span>=linux-htb \</div><div class="line">      other-config:max-rate=1000000000 \</div><div class="line">      queues:123=@vif10queue \</div><div class="line">      queues:234=@vif20queue -- \</div><div class="line">  --id=@vif10queue create queue other-config:max-rate=10000000 -- \</div><div class="line">  --id=@vif20queue create queue other-config:max-rate=20000000</div><div class="line"></div><div class="line">ovs-ofctl add-flow br0 in_port=5,actions=set_queue:123,normal</div><div class="line">ovs-ofctl add-flow br0 in_port=6,acitons=set_queue:234,normal</div></pre></td></tr></table></figure></p>
<p>上面的命令，分别把虚拟端口vif1.0，vif2.0的最大发送速率设置为10000000bps和20000000bps。<br>第2行，建立了一个网桥br0。<br>这里的<code>--</code>指当前的命令，即<code>ovs-vsctl</code>，是一种省略写法，当然也可以拆开为<code>ovs-vsctl</code>的多条命令。后面接<code>--</code>，实际是接着下一行，使第3行形成一个完整的命令。<br>第3行，把物理网卡端口eth0加入到网桥br0中。<br>第4、5行，将虚拟端口vif1.0和vif2.0加入到网桥br0中，并分别设置OpenFlow端口id为5和6。<br>第6行，设置eth0的qos规则为”newqos”，这里的<code>@</code>可以理解为变量或者指针，”newqos”这时还没有创建，接下来几行是创建它。<br>第7行，用<code>--id=@</code>开头，表示创建这个变量或者指针，赋值给它的值是后面语句的返回值。<br>后面的<code>create qos</code>表示创建了qos规则，将这个qos规则赋值给”newqos”，相当于把这个qos规则命名为”newqos”。<br>这个qos规则的类型是”linux-htb”。</p>
<p>qos规则有两个重要属性，分别是type和queues。<br>“tc”中，队列（queue）分为无类队列，有类队列。<br>无类队列只有一条队列，只有一种队列规则（qdisc）；而有类队列分为很多类（class），数据包到达时，根据不同的数据包类型，源目的ip，端口等等属性，被筛选器（filter）划分进不同的类中，不同的类可能有不同的队列规则，不同的类也可以继续划分，嵌套下去。<br>type就相当于不同的队列，具有不同的队列规则；queues就相当于有类队列的不同类。</p>
<p>这里的type值设置为”linux-htb”。<br>linux-htb使用了”tc”的htb队列（hieratchical token bucket），分层次的令牌桶队列，属于有类队列。<br>在无类队列中，最简单的是pfifo_fast队列，采取先入先出的算法，只能延迟数据包发送或丢弃数据包，不能对数据包进行调度，即改变数据包发送顺序。<br>还有一种tbf队列（token bucket filter），采取上面提到的令牌桶的算法，而htb就是在tbf的基础上修改为了有类队列，其核心算法还是令牌桶算法。<br>Open vSwitch的qos规则除了提供linux-htb类型，还提供了linux-hfsc类型，对应了”tc”中的hsfc队列（hieratchical fair service curve），分层次的公平服务曲线队列，它同时除了针对带宽，还针对延迟对数据包进行调度，其原理参考<a href="http://linux-ip.net/articles/hfsc.en" target="_blank" rel="external">http://linux-ip.net/articles/hfsc.en</a> 。</p>
<p>第8行，设置了”newqos”的一个额外属性，max-rate，表示最大发送速率，和上面的最大接收速率类似，其值为1000000000bps。<br>第9、10行，在qos规则中建立了两个queue，分别为vif10queue和vif20queue，key分别为123和234。<br>同样使用了<code>@</code>，即在第11、12行，创建了queue，并设置了最大发送速率分别为10000000bps和20000000bps，命名为vif10queue和vif20queue。<br>这两个queue属于属性queues，可以理解成htb算法中不同的类，它们的队列规则不同之处在于最大发送速率不同。<br>第14、15行，为网桥br0添加OpenFlow规则，当数据包用OpenFlow端口id为5的端口（即vif1.0）传递时，使用队列123（即vif10queue）发送；数据包用OpenFlow端口id为6（即vif2.0）传递时，使用队列234（即vif20queue）发送。<br>前面的命令全是创建qos规则，但是并没有使用，这两句才是使用qos规则的命令。<br>如果没有这两句命令，数据包发送一直使用默认的queue，没有对发送速率的限制。</p>
<p>linux-htb类型qos规则为queue提供了四种属性，上面只用到了max-rate，除此之外，还有min-rate，burst，priority。</p>
<ul>
<li>min-rate：最低发送速率，保障了最低带宽。</li>
<li>burst：桶大小，和policing部分介绍的含义一样，和突峰发送速率相关。</li>
<li>priority：优先级，数字越小，优先级越高，默认值为0。数据包发送时，发送优先级高的类里的数据包。</li>
</ul>
<blockquote>
<p>注意：openflow规则的priority值越大，优先级越高；而queue的prority值越小，优先级越高。</p>
</blockquote>
<p>而linux-hfsc的queue只有max-rate和min-rate两种属性。</p>
<p>同样在整形里面，实际的最大发送速率大于我们设置的最大发送速率，因为有突峰发送速率存在。桶大小和最大突峰发送速率的关系，参看上一节策略部分。</p>
<p>Open vSwitch和qos功能相关的命令和属性并不多，所以如果无法满足需求，只能直接使用linux的”tc”功能。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>现在来完成一个整形（shaping）的实践：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#创建网桥br0</span></div><div class="line">vs-vsctl add-br br0</div><div class="line"></div><div class="line"><span class="comment">#创建两个虚拟端口p0和p1</span></div><div class="line">ovs-vsctl add-port br0 p0 -- <span class="built_in">set</span> interface p0 <span class="built_in">type</span>=internal -- <span class="built_in">set</span> interface p0 ofport_request=10</div><div class="line">ovs-vsctl add-port br0 p1 -- <span class="built_in">set</span> interface p1 <span class="built_in">type</span>=internal -- <span class="built_in">set</span> interface p1 ofport_request=11</div><div class="line"></div><div class="line"><span class="comment">#把以太网卡eth0加入到网桥br0中</span></div><div class="line">ovs-vsctl add-port br0 eth0</div><div class="line"></div><div class="line"><span class="comment">#设置ip、网关、路由信息等，使br0能连上外网</span></div><div class="line">ifconfig eth0 0</div><div class="line">ifconfig br0 10.18.129.162/16 up</div><div class="line">route add default gw 10.18.0.254</div><div class="line">route add -net 169.254.0.0 netmask 255.255.0.0 dev br</div><div class="line"><span class="comment">#ip地址10.18.129.162/16是eth0之前的ip地址，现在将其设置到br0上</span></div><div class="line"><span class="comment">#默认网关10.18.0.254和路由169.254.0.0也分别是eth0之前的信息，现在将其设置到br0上</span></div><div class="line"><span class="comment">#另外还要把br0的ip地址设为空，因为不能和br0的ip地址冲突</span></div><div class="line"><span class="comment">#如果该环境是单网卡服务器，最好使用脚本，因为在设置过程中会造成ssh连接断开</span></div><div class="line"></div><div class="line"><span class="comment">#设置两个虚拟端口的ip分别为10.18.200.10/16和10.18.200.11/16</span></div><div class="line">ifconfig p0 10.18.200.10/16 promisc up</div><div class="line">ifconfig p1 10.18.200.11/16 promisc up</div><div class="line"></div><div class="line"><span class="comment">#清楚现在eth0上qos规则，所有qos规则及queue信息</span></div><div class="line"><span class="comment">#如果是第一次运行，可以不运行这两句命令</span></div><div class="line">ovs-vsctl clear port eth0 qos</div><div class="line">ovs-vsctl -- --all destroy QoS -- --all destroy Queue</div><div class="line"></div><div class="line"><span class="comment">#该qos规则创建两个queue，其最大发送速率为100mbps和200mbps，id为123和234</span></div><div class="line">ovs-vsctl <span class="built_in">set</span> port eth0 qos=@newqos -- \</div><div class="line">--id=@newqos create qos <span class="built_in">type</span>=linux-htb \</div><div class="line">        other-config:max-rate=2000000000 \</div><div class="line">        queues:123=@p0queue \</div><div class="line">        queues:234=@p1queue -- \</div><div class="line">--id=@p0queue create queue other-config:max-rate=100000000 -- \</div><div class="line">--id=@p1queue create queue other-config:max-rate=200000000</div><div class="line"></div><div class="line"><span class="comment">#清楚br0上所有用ip匹配的openflow规则</span></div><div class="line"><span class="comment">#如果之前没有类似规则，可以不运行这句命令</span></div><div class="line">ovs-ofctl del-flows br0 ip</div><div class="line"></div><div class="line"><span class="comment">#在br0上添加两条openflow规则，将源地址为10.18.200.10的ip数据包放入id为123的queue，将源地址为10.18.200.11的ip数据包放入id为234的queue</span></div><div class="line">ovs-ofctl add-flow br0 priority=5,ip,nw_src=10.18.200.10,actions=set_queue:123,normal</div><div class="line">ovs-ofctl add-flow br0 priority=5,ip,nw_src=10.18.200.11,actions=set_queue:234,normal</div><div class="line"><span class="comment">#注意：在nw_src/nw_dst/nw_proto等匹配规则前必须加上ip或者icmp关键字</span></div><div class="line"><span class="comment">#必须确认数据包的网络层协议类型才能使用网络层的源地址/目的地址/协议编号匹配，否则不生效</span></div><div class="line"><span class="comment">#同样，在tp_src/mod_tp_dst等匹配规则前也必须加上tcp/udp/sctp等关键字</span></div><div class="line"><span class="comment">#必须确认数据包的传输层协议类型才能使用传输层的源地址/目的地址匹配，否则不生效</span></div><div class="line"><span class="comment">#openflow规则不生效的很有可能的一种原因是其他规则的优先级更高，导致优先匹配了其他规则，即使不生效的规则匹配精度更高。</span></div></pre></td></tr></table></figure></p>
<p>现在开始发包测试，利用发包测速工具<a href="iperf.fr">iperf</a> 将数据包发往另一个节点（10.18.129.163）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#10.18.129.163</span></div><div class="line">iperf <span class="_">-s</span> -p 12345 -i 1</div><div class="line"></div><div class="line"><span class="comment">#10.18.129.162</span></div><div class="line">iperf -c 10.18.129.163 -p 12345 -i 1 -t 30 -B 10.18.200.10 &amp; \</div><div class="line">iperf -c 10.18.129.163 -p 12345 -i 1 -t 30 -B 10.18.200.11</div></pre></td></tr></table></figure></p>
<p>10.18.129.163上显示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">------------------------------------------------------------</div><div class="line">Server listening on TCP port 12345</div><div class="line">TCP window size: 85.3 KByte (default)</div><div class="line">------------------------------------------------------------</div><div class="line">[  4] <span class="built_in">local</span> 10.18.129.163 port 12345 connected with 10.18.200.10 port 12345</div><div class="line">[  5] <span class="built_in">local</span> 10.18.129.163 port 12345 connected with 10.18.200.11 port 12345</div><div class="line">[ ID] Interval       Transfer     Bandwidth</div><div class="line">[  4]  0.0- 1.0 sec  11.9 MBytes   100 Mbits/sec</div><div class="line">[  5]  0.0- 1.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4]  1.0- 2.0 sec  11.9 MBytes  99.6 Mbits/sec</div><div class="line">[  5]  1.0- 2.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4]  2.0- 3.0 sec  11.9 MBytes  99.8 Mbits/sec</div><div class="line">[  5]  2.0- 3.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  5]  3.0- 4.0 sec  23.8 MBytes   199 Mbits/sec</div><div class="line">[  4]  3.0- 4.0 sec  11.9 MBytes   100 Mbits/sec</div><div class="line">[  4]  4.0- 5.0 sec  11.9 MBytes  99.6 Mbits/sec</div><div class="line">[  5]  4.0- 5.0 sec  23.8 MBytes   199 Mbits/sec</div><div class="line">[  4]  5.0- 6.0 sec  11.9 MBytes  99.6 Mbits/sec</div><div class="line">[  5]  5.0- 6.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4]  6.0- 7.0 sec  11.9 MBytes  99.9 Mbits/sec</div><div class="line">[  5]  6.0- 7.0 sec  23.8 MBytes   199 Mbits/sec</div><div class="line">[  4]  7.0- 8.0 sec  11.9 MBytes  99.8 Mbits/sec</div><div class="line">[  5]  7.0- 8.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4]  8.0- 9.0 sec  11.9 MBytes  99.6 Mbits/sec</div><div class="line">[  5]  8.0- 9.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4]  9.0-10.0 sec  11.9 MBytes  99.6 Mbits/sec</div><div class="line">[  5]  9.0-10.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  5] 10.0-11.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4] 10.0-11.0 sec  11.9 MBytes   100 Mbits/sec</div><div class="line">[  4] 11.0-12.0 sec  11.9 MBytes  99.5 Mbits/sec</div><div class="line">[  5] 11.0-12.0 sec  23.7 MBytes   199 Mbits/sec</div><div class="line">[  4] 12.0-13.0 sec  11.9 MBytes  99.6 Mbits/sec</div><div class="line">[  5] 12.0-13.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4] 13.0-14.0 sec  11.9 MBytes  99.7 Mbits/sec</div><div class="line">[  5] 13.0-14.0 sec  23.7 MBytes   199 Mbits/sec</div><div class="line">[  5] 14.0-15.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4] 14.0-15.0 sec  11.9 MBytes   100 Mbits/sec</div><div class="line">[  4] 15.0-16.0 sec  11.9 MBytes  99.5 Mbits/sec</div><div class="line">[  5] 15.0-16.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4] 16.0-17.0 sec  11.9 MBytes  99.7 Mbits/sec</div><div class="line">[  5] 16.0-17.0 sec  23.7 MBytes   199 Mbits/sec</div><div class="line">[  4] 17.0-18.0 sec  11.9 MBytes   100 Mbits/sec</div><div class="line">[  5] 17.0-18.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  5] 18.0-19.0 sec  23.8 MBytes   199 Mbits/sec</div><div class="line">[  4] 18.0-19.0 sec  11.9 MBytes  99.6 Mbits/sec</div><div class="line">[  4] 19.0-20.0 sec  11.9 MBytes  99.6 Mbits/sec</div><div class="line">[  5] 19.0-20.0 sec  23.8 MBytes   199 Mbits/sec</div><div class="line">[  4] 20.0-21.0 sec  11.9 MBytes  99.7 Mbits/sec</div><div class="line">[  5] 20.0-21.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4] 21.0-22.0 sec  11.9 MBytes  99.8 Mbits/sec</div><div class="line">[  5] 21.0-22.0 sec  23.7 MBytes   199 Mbits/sec</div><div class="line">[  4] 22.0-23.0 sec  11.9 MBytes  99.6 Mbits/sec</div><div class="line">[  5] 22.0-23.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4] 23.0-24.0 sec  11.9 MBytes   100 Mbits/sec</div><div class="line">[  5] 23.0-24.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4] 24.0-25.0 sec  11.9 MBytes  99.6 Mbits/sec</div><div class="line">[  5] 24.0-25.0 sec  23.8 MBytes   199 Mbits/sec</div><div class="line">[  4] 25.0-26.0 sec  11.9 MBytes  99.6 Mbits/sec</div><div class="line">[  5] 25.0-26.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4] 26.0-27.0 sec  11.9 MBytes   100 Mbits/sec</div><div class="line">[  5] 26.0-27.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4] 27.0-28.0 sec  11.9 MBytes  99.6 Mbits/sec</div><div class="line">[  5] 27.0-28.0 sec  23.8 MBytes   199 Mbits/sec</div><div class="line">[  4] 28.0-29.0 sec  11.9 MBytes  99.6 Mbits/sec</div><div class="line">[  5] 28.0-29.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  4] 29.0-30.0 sec  11.9 MBytes  99.7 Mbits/sec</div><div class="line">[  5] 29.0-30.0 sec  23.8 MBytes   200 Mbits/sec</div><div class="line">[  5]  0.0-30.2 sec   718 MBytes   200 Mbits/sec</div><div class="line">[  4]  0.0-30.3 sec   361 MBytes  99.7 Mbits/sec</div></pre></td></tr></table></figure></p>
<p>可以看到最后的qos结果非常好。<br>节点10.18.129.162的两个进程使用两个不同的ip，占用两个不同的queue同时向节点10.18.129.163发包，接收方接收到数据包的带宽分别为200Mbps和99.7Mbps，符合之前发送方设置的200Mbps和100Mbps的最大发送速率。</p>
<ul>
<li>注：Open vSwitch官方文档的github地址在不断变动，上述超链接可能失效，请在<a href="http://openvswitch.org" target="_blank" rel="external">http://openvswitch.org</a> 和<a href="https://github.com/openvswitch/ovs" target="_blank" rel="external">https://github.com/openvswitch/ovs</a> 查找。</li>
</ul>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>

</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OpenFlow协议是一种网络通信协议，属于数据链路层，可以控制几换几或者路由器的转发平面（forwarding plane)，借此改变网络数据包所走的网络路径。&lt;br&gt;Open vSwitch支持OpenFlow协议，就可以控制数据包的走向，还可以修改源目的地址，支持QOS（Quality of Service）等。&lt;br&gt;本文主要介绍Open vSwitch配置OpenFlow协议以及对QOS的支持。&lt;/p&gt;
    
    </summary>
    
      <category term="openvswitch" scheme="http://aidaiz.com/categories/openvswitch/"/>
    
    
      <category term="openvswitch" scheme="http://aidaiz.com/tags/openvswitch/"/>
    
      <category term="openflow" scheme="http://aidaiz.com/tags/openflow/"/>
    
  </entry>
  
  <entry>
    <title>Open vSwitch安装与使用</title>
    <link href="http://aidaiz.com/openvswitch-build/"/>
    <id>http://aidaiz.com/openvswitch-build/</id>
    <published>2016-11-23T06:26:26.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Open vSwitch是Apache 2.0协议下，实现分布式虚拟多层网络交换机功能的产品级开源软件，其目的是为硬件虚拟化环境提供交换机堆栈，支持计算机网络中使用的多种协议和标准。其具体概念参考<a href="https://github.com/openvswitch/ovs/blob/master/Documentation/faq/general.rst" target="_blank" rel="external">官方文档</a> 。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/openvswitch-build" target="_blank" rel="external">Open vSwitch安装与使用</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x61;&#105;&#100;&#97;&#105;&#x7a;&#121;&#121;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;">&#x61;&#105;&#100;&#97;&#105;&#x7a;&#121;&#121;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2016-12-27</a></strong></p>
<p>本文使用的服务器操作系统发行版本为CentOS 6.3，kernel版本为2.6.32-279.el6.x86_64，Open vSwitch版本为2.4.1。</p>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>下载Open vSwitch，目前最新的版本为2.6.1（发布于2016.11.2），只支持kernel 3.10-4.7。因为服务器的kernel版本（2.6.32-279）较低，经测试2.4.1可以正常使用（支持kernel 2.6.32-4.0），更高的还有2.5.1(支持kernel 2.6.32-4.3)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo wget http://openvswitch.org/releases/openvswitch-2.4.1.tar.gz</div></pre></td></tr></table></figure></p>
<p>如需其他版本，把上面的2.4.1替换为2.6.1或者2.5.1或者更低的版本。<br>或者直接到官网<a href="http://openvswitch.org/download" target="_blank" rel="external">http://openvswitch.org/download</a> 下载。</p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>安装Open vSwitch需要准备的环境，可以参考<a href="https://github.com/openvswitch/ovs/blob/master/Documentation/intro/install/general.rst" target="_blank" rel="external">https://github.com/openvswitch/ovs/blob/master/Documentation/intro/install/general.rst</a> 的”Build Requirements”部分。<br>摘自官方文档：<br>需要的软件：</p>
<ul>
<li>GNU make</li>
<li>编译器：GCC 4.x/Clang 3.4</li>
<li>libssl：可选，在需要连接ovs（Open vSwitch）到OpenFlows控制器时推荐安装</li>
<li>libcap-ng：可选，在需要非root用户使用root权限运行ovs后台程序时推荐安装</li>
<li>Pyhton 2.7<br>其他情况的软件及需要的内核模块自行参考官方文档。</li>
</ul>
<p>如果要编译内核模块，需要与内核版本一致的内核源代码，通常位于<code>/usr/src/kernels/&lt;version&gt;</code>或者<code>/usr/src/&lt;versio&gt;</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /lib/modules/&lt;version&gt;</div><div class="line">ls <span class="_">-l</span> build</div></pre></td></tr></table></figure></p>
<p><version>指内核版本，用<code>uname -r</code>得到。<br>如果打印了一个目录列表，直接进行编译；<br>如果打印了<code>No such file or directory error</code>，执行以下操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /lib/modules/&lt;version&gt;</div><div class="line">rm build</div><div class="line">ln <span class="_">-s</span> /usr/src/kernels/&lt;version&gt; build</div></pre></td></tr></table></figure></version></p>
<p>或者为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /lib/modules/&lt;version&gt;</div><div class="line">rm build</div><div class="line">ln <span class="_">-s</span> /usr/src/&lt;version&gt; build</div></pre></td></tr></table></figure></p>
<p>重复上面的步骤验证是否生效。</p>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar -xvzf openvswitch-2.4.1.tar.gz</div><div class="line"><span class="built_in">cd</span> openvswitch-2.4.1</div><div class="line">./configure --with-linux=/lib/modules/$(uname -r)/build</div></pre></td></tr></table></figure>
<p>配置编译内核模块，如果不需要基于内核的交换机（可以只运行在用户态空间中），即直接<code>./configure</code>。<br>其他配置，参考上面链接的官方文档。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">make</div><div class="line">make install</div><div class="line">make modules_install</div></pre></td></tr></table></figure>
<p><code>make modules_install</code>编译内核模块，可以不用执行。<br>在编译内核模块的过程中，需要<code>/lib/modules/&lt;version&gt;/build/include/generated/utsrelease.h</code>，可能会遇到较低kenrel版本中的指定位置并没有文件<code>utsrelease.h</code>的错误，我们可以在<code>&lt;version&gt;/build/include/linux/utsrelease.h</code>找到该文件，把它复制到<code>.../generated/utsrelease.h</code>，重新编译。</p>
<h2 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h2><p>如果不需要基于内核的交换机，没有编译内核模块，可以跳过这一步。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">modprobe openvswitch</div></pre></td></tr></table></figure></p>
<p>因为openvswitch模块与linux的bridge模块冲突，所以如果发生冲突，不能加载ovs的内核模块时，先卸载掉bridge模块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rmmod bridge</div><div class="line">modprobe openvswitch</div></pre></td></tr></table></figure></p>
<p>用<code>lsmod</code>查看已加载的所有模块，验证是否加载ovs的内核模块成功。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsmod | grep openvswitch</div></pre></td></tr></table></figure></p>
<p>如果一直加载模块不成功，可以用命令<code>modinfo openvswitch</code>查看该模块的信息，内核版本以及依赖关系等。或者用<code>dmesg | tail</code>查看kernel的日志信息。</p>
<p>关于ovs的内核模块的作用，可以参考<a href="https://github.com/openvswitch/ovs/blob/master/Documentation/intro/why-ovs.rst" target="_blank" rel="external">https://github.com/openvswitch/ovs/blob/master/Documentation/intro/why-ovs.rst</a> 。</p>
<h2 id="初始操作"><a href="#初始操作" class="headerlink" title="初始操作"></a>初始操作</h2><p>遇到权限不够时，使用<code>sudo</code>命令或<code>root</code>用户，或者<code>libcap-ng</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir -p /usr/<span class="built_in">local</span>/etc/openvswitch</div><div class="line"><span class="built_in">cd</span> openvswitch-2.4.1</div><div class="line">ovsdb-tool create /usr/<span class="built_in">local</span>/etc/openvswitch/conf.db vswitchd/vswitch.ovsschema</div></pre></td></tr></table></figure>
<p>创建配置数据库<br><code>vswitch.ovsschema</code>是一个数据库模板，存放在<code>openvswitch-2.4.1/vswitchd/vswitch.ovsschema</code>。<br><code>conf.db</code>是数据库文件，是<code>vswith.ovsschema</code>的一份拷贝。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mkdir -p /usr/<span class="built_in">local</span>/var/run/openvswitch</div><div class="line">ovsdb-server --remote=punix:/usr/<span class="built_in">local</span>/var/run/openvswitch/db.sock \</div><div class="line">    --remote=db:Open_vSwitch,Open_vSwitch,manager_options \</div><div class="line">    --private-key=db:Open_vSwitch,SSL,private_key \</div><div class="line">    --certificate=db:Open_vSwitch,SSL,certificate \</div><div class="line">    --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \</div><div class="line">    --pidfile --detach</div></pre></td></tr></table></figure>
<p>创建连接到上面创建的配置数据库的Unix domain socket，以便管理员能管理数据库。<br>如果不需要SSL支持，删除掉<code>--private</code>，<code>--certificate</code>，<code>--bootstrap</code>。<br>执行以上操作后，开启了进程<code>ovsdb-server</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ovs-vsctl --no-wait init</div></pre></td></tr></table></figure>
<p>对数据库进行初始化。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ovs-vswitchd --pidfile --detach --log-file</div></pre></td></tr></table></figure>
<p>开启ovs后台程序，连接到上面创建的Unix domain socket。一个后台程序可以管理和控制本机上任意数量的ovs交换机。<br><code>--pidfile</code>的意思是创建一个运行的进程文件，默认路径为<code>/usr/local/var/run/openvswitch/</code>，可以用<code>ovs-appctl</code>管理该后台程序。<br><code>--detach</code>的意思是在后台运行。<br><code>--log-file</code>的意思是创建一个日志文件，默认路径为<code>/usr/local/var/log/openvswitch/</code>，可以查看该后台程序的日志。<br>其他参数可通过<code>man ovs-vswitchd</code>查看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ea | grep ovs</div></pre></td></tr></table></figure>
<p>用<code>ps</code>命令查看当前运行的ovs进程，一共有两个进程，分别是ovs-server和ovs-vswitchd。<br>这两个进程的pidfile都在<code>/usr/local/var/run/openvswitch/</code>中，可以用<code>ovs-appctl</code>管理。</p>
<h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p><code>ovs-vsctl</code>命令主要是把配置信息更新到数据库中。</p>
<h3 id="添加网桥"><a href="#添加网桥" class="headerlink" title="添加网桥"></a>添加网桥</h3><p>创建ovs网桥br0<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ovs-vsctl add-br br0</div></pre></td></tr></table></figure></p>
<p>ovs网桥就表示以太网交换机（Switch）。<br>如果没有加载openvswitch内核模块，以上操作会报错，在日志文件中可以得到详情。如果想要ovs完全运行在用户态空间中，不使用内核模块，进行以下操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ovs-vsctl add-br br0 -- <span class="built_in">set</span> bridge br0 datapath_type=netdev</div></pre></td></tr></table></figure></p>
<p><code>--</code>替代<code>ovs-vsctl</code>命令，也可以拆成两个语句执行。<br>后面的操作表示把数据库中ovs网桥br0的datapath_type属性的值设为netdev，对br0的其他属性设置操作类似。<br>netdev表示用户态数据通路，system表示内核数据通路。</p>
<p>关于用户态空间ovs的更多资料，可以参考<a href="https://github.com/openvswitch/ovs/blob/master/Documentation/intro/install/userspace.rst" target="_blank" rel="external">https://github.com/openvswitch/ovs/blob/master/Documentation/intro/install/userspace.rst</a> 。</p>
<p>删除ovs网桥br0<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ovs-vsctl del-br br0</div></pre></td></tr></table></figure></p>
<h3 id="添加端口"><a href="#添加端口" class="headerlink" title="添加端口"></a>添加端口</h3><p>为br0添加端口p0<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ovs-vsctl add-port br0 p0</div></pre></td></tr></table></figure></p>
<p>同样会报错，因为根本实际没有p0这个端口。<br>我们把p0的类型设置为虚拟端口可以解决这个问题。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ovs-vsctl <span class="built_in">set</span> interface p0 <span class="built_in">type</span>=internal</div></pre></td></tr></table></figure></p>
<p>interface是连接到port的网络接口设备，一对一关系，可以直接理解为port。<br>其他类型还有system、tap、geneve、gre、ipsec_gre、vxlan、lisp、stt、patch、null等。</p>
<p>删除端口p0<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ovs-vsctl del-port p0</div></pre></td></tr></table></figure></p>
<h3 id="网桥接管以太网卡"><a href="#网桥接管以太网卡" class="headerlink" title="网桥接管以太网卡"></a>网桥接管以太网卡</h3><p>br0接管以太网卡端口eth0<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ovs-vsctl add-port br0 eth0</div></pre></td></tr></table></figure></p>
<p>因为eth0是实际存在的端口，不需要特意设置类型为internal。<br>这时存在一个问题，以上操作执行后，eth0直接断网，不能连接到外网，如果使用ssh连接的服务器的就要小心了。<br>（实际使用中发现只有在内核模式下才会断网，用户态模式下不会断网。）</p>
<p>要解决这个问题，只需要把eth0的相同ip/子网掩码/网关等设置移植给br0即可。<br>比如eth0的ip为192.168.1.100，子网掩码为255.255.0.0，网关为192.168.0.254。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ifconfig br0 192.168.1.100 netmask 255.255.0.0</div><div class="line">ifconfig br0 up</div><div class="line">ifconfig eth0 0.0.0.0</div></pre></td></tr></table></figure></p>
<p>注意还要把eth0的ip清空后。<br>在清空eth0的ip之前，最好执行<code>route -n</code>命令，观察eth0现有的路由设置，避免br0的路由设置出错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">route add default gw 192.168.0.254</div></pre></td></tr></table></figure></p>
<p>上面设置了默认网关，其他的路由设置自行查询<code>route</code>命令用法设置。<br>这时能ping通外网的话，表示设置成功。</p>
<p><code>ovs-vsctl show</code>显示ovs交换机的信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ ovs-vsctl show</div><div class="line">89da09a9<span class="_">-a</span>172-4e62-b4a0-afc36760ad16</div><div class="line">    Bridge <span class="string">"br0"</span></div><div class="line">        Port <span class="string">"p0"</span></div><div class="line">            Interface <span class="string">"p0"</span></div><div class="line">                <span class="built_in">type</span>: internal</div><div class="line">        Port <span class="string">"br0"</span></div><div class="line">            Interface <span class="string">"br0"</span></div><div class="line">                <span class="built_in">type</span>: internal</div><div class="line">        Port <span class="string">"eth0"</span></div><div class="line">            Interface <span class="string">"eth0"</span></div></pre></td></tr></table></figure></p>
<h3 id="虚拟端口连接外网"><a href="#虚拟端口连接外网" class="headerlink" title="虚拟端口连接外网"></a>虚拟端口连接外网</h3><p>实际上这时p0在网桥中，已经连接到外网了，但还不能使用，因为p0还没有up。<br>同样设置ip和子网掩码，然后用混杂模式up。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ifconfig p0 192.168.1.101 netmask 255.255.0.0</div><div class="line">ifconfig p0 promisc up</div></pre></td></tr></table></figure></p>
<p>混杂模式可以接收非本ip的数据包，如果不使用混杂模式，接收到非本ip的数据包直接丢弃，在交换机该场景下需要使用混杂模式。</p>
<p>这时通过指定ping外网，就可以验证是否成功。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ping -I p0 http://www.baidu.com</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里可能会有疑问，为什么不直接创建一个tap设备来替代这个虚拟端口？关于这个问题，在<a href="https://github.com/openvswitch/ovs/blob/master/Documentation/faq/issues.rst" target="_blank" rel="external">https://github.com/openvswitch/ovs/blob/master/Documentation/faq/issues.rst</a> 其中的“Q: I created a tap device tap0, configured an IP address on it, and add it to a bridge. I exacped that I counld then use this IP address to contract other hosts on the network, but it doesn’t work. Why not?”部分有解答。<br>除了ovs内部的虚拟端口，加入ovs的其他网络设备发送的数据包都会被丢弃。假如我们在tap设备上ping任意一个ip地址，tap设备将会发送ARP数据包，但是这些ARP数据包都会被丢弃，所以tap设备无法正常工作。在上面的场景中，只能用ovs内部的虚拟端口来实现。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Open vSwitch官网：<a href="http://openvswitch.org" target="_blank" rel="external">http://openvswitch.org</a></li>
<li>Github地址：<a href="https://github.com/openvswitch/ovs" target="_blank" rel="external">https://github.com/openvswitch/ovs</a></li>
</ul>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Open vSwitch是Apache 2.0协议下，实现分布式虚拟多层网络交换机功能的产品级开源软件，其目的是为硬件虚拟化环境提供交换机堆栈，支持计算机网络中使用的多种协议和标准。其具体概念参考&lt;a href=&quot;https://github.com/openvswitch/ovs/blob/master/Documentation/faq/general.rst&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="openvswitch" scheme="http://aidaiz.com/categories/openvswitch/"/>
    
    
      <category term="openvswitch" scheme="http://aidaiz.com/tags/openvswitch/"/>
    
      <category term="openflow" scheme="http://aidaiz.com/tags/openflow/"/>
    
  </entry>
  
  <entry>
    <title>SSH秘钥与SSHFS挂载</title>
    <link href="http://aidaiz.com/ssh/"/>
    <id>http://aidaiz.com/ssh/</id>
    <published>2016-08-25T07:37:54.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>SSH通过秘钥（公钥与私钥）完成免密SSH连接。<br>SSHFS挂载远程目录到本地，本地操作同步到远程目录。<br><a id="more"></a><br><strong>Title: <a href="https://aidaizyy.github.io/ssh" target="_blank" rel="external">SSH秘钥与SSHFS挂载</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#97;&#105;&#100;&#x61;&#105;&#x7a;&#121;&#x79;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;">&#97;&#105;&#100;&#x61;&#105;&#x7a;&#121;&#x79;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2016-08-25</a></strong></p>
<h2 id="查看已有的秘钥"><a href="#查看已有的秘钥" class="headerlink" title="查看已有的秘钥"></a>查看已有的秘钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ~/.ssh</div><div class="line">ls</div></pre></td></tr></table></figure>
<p>以.pub结尾的文件就是公钥，而与.pub前字符串相同的文件就是与之对应的私钥。</p>
<h2 id="创建新的秘钥"><a href="#创建新的秘钥" class="headerlink" title="创建新的秘钥"></a>创建新的秘钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C “usr@email”</div></pre></td></tr></table></figure>
<p>参数“rsa”是加密方式，其他可选的加密方式有dsa；<br>参数“-C”后面接注释。<br>创建过程中会要求输入存放的文件名，直接回车默认是id_rsa和id_rsa.pub或id_dsa和id_dsa.pub；<br>还会要求输入密码，直接回车默认为空。</p>
<h2 id="机器A登录机器B"><a href="#机器A登录机器B" class="headerlink" title="机器A登录机器B"></a>机器A登录机器B</h2><p>在.ssh目录下有authorized_keys文件，把机器A生成的公钥拷贝到机器B的authorized_keys文件中，机器A就可以免密登录机器B；</p>
<h2 id="设置文件和目录权限"><a href="#设置文件和目录权限" class="headerlink" title="设置文件和目录权限"></a>设置文件和目录权限</h2><p>一般依据默认权限，如果不小心删除了，新建文件和目录，就必须设置权限。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod 600 authorized_keys</div><div class="line">chmod 700 -R .ssh</div></pre></td></tr></table></figure></p>
<h2 id="添加秘钥到SSH-AGENT"><a href="#添加秘钥到SSH-AGENT" class="headerlink" title="添加秘钥到SSH-AGENT"></a>添加秘钥到SSH-AGENT</h2><p>ssh-agent就是秘钥管理器，需要把私钥添加进去才可以使用ssh;<br>先确保ssh-agent是否可用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(ssh-agent -s)</span>"</span></div><div class="line">-&gt; Agent pid 59566</div></pre></td></tr></table></figure></p>
<p>然后添加私钥：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-add ~/.ssh/id_rsa</div></pre></td></tr></table></figure></p>
<p>可以查看ssh-agent中已有的私钥：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-add <span class="_">-l</span></div></pre></td></tr></table></figure></p>
<h2 id="SSH连接服务器"><a href="#SSH连接服务器" class="headerlink" title="SSH连接服务器"></a>SSH连接服务器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh usrname@ipaddr</div></pre></td></tr></table></figure>
<p>logout：注销用户，exit：逐层退出控制台。</p>
<h2 id="GitHub和Coding公钥添加"><a href="#GitHub和Coding公钥添加" class="headerlink" title="GitHub和Coding公钥添加"></a>GitHub和Coding公钥添加</h2><p>在各自的设置页面，把公钥，也就是.pub文件中的内容拷贝到设置中指定的输入框即可生效；对应的私钥需要添加到ssh-agent中。<br>github的ssh秘钥是否生效可以进行测试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh git@github.com</div></pre></td></tr></table></figure></p>
<h2 id="SSHFS挂载"><a href="#SSHFS挂载" class="headerlink" title="SSHFS挂载"></a>SSHFS挂载</h2><p>在配置ssh秘钥免密登录后，可以用sshfs把远程目录挂载到本地上，比如把服务器上的目录挂载过来，通过本地的编程环境（IDE、插件等）编辑代码文件。<br>Linux系统直接通过apt-get或者yum安装sshfs。<br>Mac OS X系统需要安装osxfuse和其对应的sshfs：<br>安装FUSE for OS X：<a href="https://osxfuse.github.io；" target="_blank" rel="external">https://osxfuse.github.io；</a><br>安装SSHFS：<a href="https://github.com/osxfuse/sshfs/releases；" target="_blank" rel="external">https://github.com/osxfuse/sshfs/releases；</a><br>两者都可以通过brew安装。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sshfs -o allow_other user@host:dir localdir</div></pre></td></tr></table></figure></p>
<p>user指远程用户名，host指远程主机地址，dir指要挂载的远程目录，localdir指挂载到的本地目录。<br>-o 后面接相关参数，比如：</p>
<ul>
<li>-o reconnect：自动重连</li>
<li>-o allow_other：无视用户权限</li>
<li>-o cache=yes：支持cache</li>
</ul>
<p>卸载远程目录，使用卸载设备命令“umount”。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">umount localdir</div></pre></td></tr></table></figure></p>
<p>其他相关参数可以查阅资料或者通过<code>sshfs -h</code>了解。</p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SSH通过秘钥（公钥与私钥）完成免密SSH连接。&lt;br&gt;SSHFS挂载远程目录到本地，本地操作同步到远程目录。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://aidaiz.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>SPDK简介</title>
    <link href="http://aidaiz.com/spdk/"/>
    <id>http://aidaiz.com/spdk/</id>
    <published>2016-08-15T15:02:27.000Z</published>
    <updated>2017-05-09T13:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>SPDK（Storage Performance Development Kit）是Intel发布的存储性能开发工具集。</p>
<blockquote>
<p>原文：<a href="https://software.intel.com/en-us/articles/introduction-to-the-storage-performance-development-kit-spdk" target="_blank" rel="external">《Introduction to the Storage Performance Development Kit (SPDK)》</a></p>
</blockquote>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/spdk" target="_blank" rel="external">SPDK简介</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#x61;&#105;&#x64;&#97;&#x69;&#122;&#x79;&#121;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#x61;&#105;&#x64;&#97;&#x69;&#122;&#x79;&#121;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2017-05-09</a></strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>固态存储设备正在取代数据中心。目前这一代的闪存存储，比起传统的磁盘介质，在性能（performance）、功耗（power consumption）和机架密度（rack density）上具有显著的优势。这些优势将会继续增大，使闪存存储作为下一代设备进入市场。</p>
<p>用户使用现在的固态设备，比如Intel® SSD DC P3700 Series Non-Volatile Memory Express（NVMe）驱动，面临一个主要的挑战：因为吞吐量和延迟性能比传统的磁盘好太多，现在总的处理时间中，存储软件占用了更大的比例。换句话说，存储软件栈的性能和效率在整个存储系统中越来越重要。随着存储设备继续发展，它将面临远远超过正在使用的软件体系结构的风险（即存储设备受制于相关软件的不足而不能发挥全部性能），在接下来的几年中，存储设备将会继续发展到一个令人难以置信的地步。</p>
<p>为了帮助存储OEM（设备代工厂）和ISV（独立软件开发商）整合硬件，Inte构造了一系列驱动，以及一个完善的、端对端的参考存储体系结构，被命名为Storage Performance Development Kit（SPDK）。SPDK的目标是通过同时使用Intel的网络技术，处理技术和存储技术来提高突出显著的效率和性能。通过运行为硬件设计的软件，SPDK已经证明很容易达到每秒钟数百万次I/O读取，通过使用许多处理器核心和许多NVMe驱动去存储，而不需要额外卸载硬件。Intel在<a href="https://github.com/spdk/spdk/blob/master/LICENSE" target="_blank" rel="external">BSD license</a>许可协议下通过<a href="https://github.com/spdk" target="_blank" rel="external">Github</a>分发提供其全部的Linux参考架构的源代码。博客、邮件列表和额外文档可以在<a href="http://www.spdk.io" target="_blank" rel="external">spdk.io</a>中找到。</p>
<h2 id="软件体系结构概览"><a href="#软件体系结构概览" class="headerlink" title="软件体系结构概览"></a>软件体系结构概览</h2><p>SPDK如何工作？达到这样的超高性能运用了两个关键技术：运行于用户态和轮询模式。让我们进一步了解这两个软件工程术语。</p>
<p>首先，我们的设备驱动代码运行在用户态意味着，在定义上驱动代码不会运行在内核中。避免内核上下文切换和中断将会节省大量的处理开销，允许更多的时钟周期被用来做实际的数据存储。无视复杂的存储算法（去冗，加密，压缩，空白块存储），更少的浪费时钟周期意味着更好的性能和延迟。这并不是说内核增加了不必要的开销；相反，内核增加了那些可能不适用于专用存储堆栈的通用计算用例的相关开销。SPDK的指导原则是通过消除每一处额外的软件开销来提供最少的延迟和最高的效率。</p>
<p>其次，轮询模式驱动（Polled Mode Drivers, PMDs）改变了I/O的基本模型。在传统的I/O模型中，应用程序提交读写请求后睡眠，一旦I/O完成，中断就会将其唤醒。PMDs的工作方式不同，应用程序提交读写请求后继续执行其他工作，以一定的时间间隔回头检查I/O是否已经完成。这种方式避免了中断带来的延迟和开销，并使得应用程序提高了I/O的效率。在旋转设备时代（磁带和机械硬盘），中断开销只占整个I/O时间的一个很小的百分比，因此给系统带来了巨大的效率提升。然而，在固态设备的时代，持续引入更低延迟的持久化设备，中断开销成为了整个I/O时间中不能被忽视的部分。这个问题在更低延迟的设备上只会越来越严重。系统已经能够每秒处理数百万个I/O，所以消除数百万个事务的这种开销，能够快速地复制到多个内核中。数据包和数据块被立即分派，因为等待花掉的时间变小，使得延迟更低，一致性延迟更多（抖动更少），吞吐量也得到提高。</p>
<p>SPDK由数个子组件构成，相互连接并共享用户态操作和轮询模式操作的共有部分。当构造端对端SPDK体系结构时，每个组件被构造用于克服遭遇到的特定的性能瓶颈。然而，每个组件也可以被整合进非SPDK体系结构，允许用户利用SPDK中使用的经验和技术来加速自己的软件。</p>
<p><img src="https://software.intel.com/sites/default/files/managed/a8/ff/introduction-to-the-storage-performance-development-kit-spdk-fig2.png" alt="SPDK Architecture"></p>
<p>我们从下往上构建：</p>
<p><strong>硬件驱动</strong></p>
<p>NVMe Driver：SPDK的基础组件，这个高优化无锁的驱动提供了高扩展性，高效性和高性能。</p>
<p>Inter QuickData Technology：也称为Intel I/O Acceleration Technology（Inter IOAT，英特尔I/O加速技术），这是一种基于Xeon处理器平台上的copy offload引擎。通过提供用户空间访问，减少了DMA数据移动的阈值，允许对小尺寸I/O或NTB的更好利用。</p>
<p><strong>后端块设备</strong></p>
<p>NVMe over Fabrics（NVMe-oF）initiator：从程序员的角度来看，本地SPDK NVMe驱动和NVMe-oF启动器共享一套共同的API命令。这意味着，比如本地/远程复制非常容易实现。</p>
<p>Ceph RADOS Block Device（RBD）：使Ceph成为SPDK的后端设备，比如这可能允许Cepy用作另一个存储层。</p>
<p>Blobstore Block Device：由SPDK Blobstore分配的块设备，是虚拟机或数据库可以与之交互的虚拟设备。这些设备得到SPDK基础架构的优势，意味着零拷贝和令人难以置信的可扩展性。</p>
<p>Linux Asynchrounous I/O（AIO）：允许SPDK与内核设备（比如机械硬盘）交互。</p>
<p><strong> 存储服务 </strong></p>
<p>Block device abstration layer（bdev）：这种通用的块设备抽象是连接到各种不同设备驱动和块设备的存储协议的粘合剂。还在块层中提供灵活的API用于额外的用户功能（磁盘阵列，压缩，去冗等等）。</p>
<p>Blobstore：为SPDK实现一个高精简的文件式语义（非POSIX）。这可以为数据库，容器，虚拟机或其他不依赖于大部分POSIX文件系统功能集（比如用户访问控制）的工作负载提供高性能基础。</p>
<p><strong> 存储协议 </strong></p>
<p>iSCSI target：建立了通过以太网的块流量规范，大约是内核LIO效率的两倍。现在的版本默认使用内核TCP/IP协议栈。</p>
<p>NVMe-oF target：实现了<a href="http://www.nvmexpress.org/specifications" target="_blank" rel="external">新NVMe-oF规范</a>。虽然这取决于RDMA硬件，NVMe-oF的目标可以为每个CPU核提供高达40Gbps的流量。</p>
<p>vhost-scsi target：KVM/QEMU的功能利用了SPDK NVMe驱动，使得访客虚拟机访问存储设备时延迟更低，使得I/O密集型工作负载的整体CPU负载减低。</p>
<p>SPDK不适应所有的存储体系结构。这里有一些问题可能会帮助用户决定SPDK组件是否适合你们的体系结构。</p>
<p><strong>这个存储系统是否基于Linux或FreeBSD？</strong><br>SPDK主要在Linux上测试和支持。硬件驱动被FreeBSD和Linux支持。</p>
<p><strong>存储系统的硬件平台是否要求是Intel体系结构？</strong><br>SPDK被设计为充分利用Intel平台的特性，并针对Intel芯片和系统测试和调整。</p>
<p><strong>这个存储系统的高性能路径是否运行在用户态？</strong><br>SPDK通过更多地在用户态下运行从网卡到磁盘的高性能路径，提高性能和效率。通过将具有SPDK功能（比如NVMe-oF目标，NVMe-oF启动器，Blobstore）的应用程序结合起来，整个数据通路可能能够在用户空间运行，从而提供显著的高效率。</p>
<p><strong>系统体系结构可以合并无锁的PMDs到它的线程模型吗？</strong><br>因为PMD持续运行在它们的线程中（而不是睡眠或者不用时让出处理器），所以它们有特殊的线程模型需求</p>
<p><strong>系统现在是否用DPDK处理网络数据包的工作负载</strong><br>SPDK和DPDK共享早期的编程模型，所以现在使用DPDK的用户可能会发现与SPDK紧密整合非常有用。类似地，如果正在使用SPDK的用户为网络处理添加DPDK功能将会带来重大机会。</p>
<p><strong>开发团队自己是否具有理解和解决问题的专业技能？</strong><br>Intel没有为相关软件提供支持的义务。当Intel和围绕SPDK的开源社区将付出商业上合理的努力去调出未修改的发布版本软件的潜在错误，任何情况下Intel都没有任务义务为用户提供针对该软件任何形式的维护和支持。</p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SPDK（Storage Performance Development Kit）是Intel发布的存储性能开发工具集。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://software.intel.com/en-us/articles/introduction-to-the-storage-performance-development-kit-spdk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Introduction to the Storage Performance Development Kit (SPDK)》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="spdk" scheme="http://aidaiz.com/categories/spdk/"/>
    
    
      <category term="spdk" scheme="http://aidaiz.com/tags/spdk/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop安装运行</title>
    <link href="http://aidaiz.com/hadoop/"/>
    <id>http://aidaiz.com/hadoop/</id>
    <published>2016-05-29T06:18:57.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hadoop：是一个由Apache基金会所开发的处理计算机集群上大数据的开源分布式系统基础框架。<br>本文基于Mac OSX 10.11操作系统和Hadoop 2.6.4。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/hadoop" target="_blank" rel="external">Hadoop安装运行</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x61;&#105;&#x64;&#x61;&#x69;&#122;&#121;&#x79;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#x61;&#105;&#x64;&#x61;&#x69;&#122;&#121;&#x79;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2016-05-29</a></strong></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><p>Hadoop是由Java实现的，所以首先确入是否已经安装Java。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure></p>
<p>在终端中输入以上命令，确认是否安装Java。如果没有，可以去<a href="http://www.java.com" target="_blank" rel="external">Java官方网站</a>下载，并参照说明配置环境变量。如果已经安装Java，可以进行下一步。<br>本文基于JDK 1.8安装Hadoop。官方要求至少java 1.5及其以上版本。</p>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>其次，确认ssh安装，且sshd一直运行，以便Hadoop脚本管理远端Hadoop守护进程。<br>Mac系统已自带ssh，可通过以下三条命令验证。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">which</span> ssh</div><div class="line"><span class="built_in">which</span> sshd</div><div class="line"><span class="built_in">which</span> ssh-Keygen</div></pre></td></tr></table></figure></p>
<p>得到ssh路径。<br>我们要实现无密码登录ssh。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa</div></pre></td></tr></table></figure></p>
<p>输入以上命令，需要输入密码时按enter键。<br>成功后进入ssh目录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ~/.ssh</div><div class="line">cp id_rsa.pub authorized_keys</div></pre></td></tr></table></figure></p>
<p>下面验证是否成功。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh localhost</div></pre></td></tr></table></figure></p>
<p>如果出现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh: connect to host localhost port 22: Connection refuse</div></pre></td></tr></table></figure></p>
<p>说明用户没有权限，需要去“系统偏好设置”——“共享”——“远程登录”，勾选并选择允许访问：“所有用户”。</p>
<p>注意，在Windows系统下，需要安装Cygwin，提供shell支持。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h3 id="下载Hadoop"><a href="#下载Hadoop" class="headerlink" title="下载Hadoop"></a>下载Hadoop</h3><p>前往<a href="http://hadoop.apache.org/releases.html" target="_blank" rel="external">Apache Hadoop官方网站</a>下载Hadoop发行版。本文下载了最新修改发布的2.6.4版本（2016年2月），选择<a href="http://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-2.6.4/hadoop-2.6.4.tar.gz" target="_blank" rel="external">binary版本</a>，如果选择了source版本，压缩包后会有-src后缀，表示源码，需要额外编译。</p>
<h3 id="解开压缩包"><a href="#解开压缩包" class="headerlink" title="解开压缩包"></a>解开压缩包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -xvzf hadoop-2.6.4.tar.gz</div></pre></td></tr></table></figure>
<p>我这里将其放置的路径是~/Applications（本文的路径是/Users/zhangyunyao/Applications/hadoop-2.6.4）。</p>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>在~/.bash_profile文件或~/.profile文件中添加环境变量（本文在zsh环境下，在~/.zshrc中添加环境变量）。</p>
<p><strong>添加JAVA_HOME环境变量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=`/usr/libexec/java_home`</div></pre></td></tr></table></figure></p>
<p>将上面句子加在环境变量文件末尾，并用source命令更新。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> .zshrc</div></pre></td></tr></table></figure></p>
<p>验证JAVA_HOME环境变量是否设置成功。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></div></pre></td></tr></table></figure></p>
<p>如果返回Java路径则说明设置成功。</p>
<p><strong>添加HADOOP_HOME环境变量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export HADOOP_HOME=/Users/zhangyunyao/Applications/hadoop-2.6.4</div></pre></td></tr></table></figure></p>
<p>将上面句子加载环境变量文件末尾，同样可以用source命令更新和echo命令验证。</p>
<p><strong>添加其他可能用到的环境变量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</div><div class="line">export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib</div></pre></td></tr></table></figure></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>进入hadoop-2.6.4目录后，主要配置四个文件（hadoop-env.sh，core-site.xml，mapred-site.xml，hdfs-site.xml），很多资料显示这四个文件在conf目录里。但在Hadoop 2.5以后，这四个文件都在etc/hadoop文件夹下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> hadoop-2.6.4/etc/hadoop</div></pre></td></tr></table></figure></p>
<h3 id="编辑hadoop-env-sh文件"><a href="#编辑hadoop-env-sh文件" class="headerlink" title="编辑hadoop-env.sh文件"></a>编辑hadoop-env.sh文件</h3><p>该文件涉及Hadoop的配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=$&#123;JAVA_HOME&#125;</div></pre></td></tr></table></figure></p>
<p>因为我们在环境配置中已经设置了JAVA_HOME的值，所以这里可以不用修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#export HADOOP_HEADSIZE=</div></pre></td></tr></table></figure></p>
<p>表示Hadoop堆可用的最大大小，默认是1000MB。没有特殊需求，可以不用修改。修改的话去掉注释符号“#”，并在“=”后面加上数字，比如“=2000”，表示2000MB。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export HADOOP_OPTS=&quot;$HADOOP_OPTS -Djava.net.preferIPv4Stack=true&quot;</div></pre></td></tr></table></figure></p>
<p>已经有默认值，暂时不需要修改。</p>
<h3 id="编辑core-site-xml文件"><a href="#编辑core-site-xml文件" class="headerlink" title="编辑core-site.xml文件"></a>编辑core-site.xml文件</h3><p>参考官方提供的默认文件<a href="http://hadoop.apache.org/docs/r2.6.4/hadoop-project-dist/hadoop-common/core-default.xml" target="_blank" rel="external">core-default.xml</a>，其他版本都可以在官网找到对应的默认文件。<br>“hadoop.tmp.dir”表示临时目录，“fs.default.name”表示缺省的文件URI标识，这里设置了主机名和端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line"> 	&lt;property&gt;</div><div class="line">    		&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</div><div class="line">    		&lt;value&gt;/Users/zhangyunyao/Applications/hadoop-2.6.4/tmp/hadoop-$&#123;user.name&#125;&lt;/value&gt;</div><div class="line">    		&lt;description&gt;A base for other temporary directories.&lt;/description&gt;</div><div class="line">  	&lt;/property&gt;</div><div class="line">  	&lt;property&gt;</div><div class="line">    		&lt;name&gt;fs.default.name&lt;/name&gt;</div><div class="line">    		&lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</div><div class="line">  	&lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<h3 id="编辑hdfs-site-xml文件"><a href="#编辑hdfs-site-xml文件" class="headerlink" title="编辑hdfs-site.xml文件"></a>编辑hdfs-site.xml文件</h3><p>参考官方提供的默认文件<a href="http://hadoop.apache.org/docs/r2.6.4/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml" target="_blank" rel="external">hdfs-default.xml</a>，其他版本都可以在官网找到对应的默认文件。<br>“dfs.replication”表示缺省的块复制数量，因为这里只有一个节点，所以值设为1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">    	&lt;property&gt;</div><div class="line">        	&lt;name&gt;dfs.replication&lt;/name&gt;</div><div class="line">        	&lt;value&gt;1&lt;/value&gt;</div><div class="line">    	&lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<h3 id="编辑mapred-site-xml文件"><a href="#编辑mapred-site-xml文件" class="headerlink" title="编辑mapred-site.xml文件"></a>编辑mapred-site.xml文件</h3><p>参考官方提供的默认文件<a href="http://hadoop.apache.org/docs/r2.6.4/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml" target="_blank" rel="external">mapred-default.xml</a>，其他版本都可以在官网找到对应的默认文件。<br>“mapreduce.jobtracker.address”表示JobTracker作业跟踪器的地址，这里设置了它的主机名和端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;mapreduce.jobtracker.address&lt;/name&gt;</div><div class="line">		&lt;value&gt;localhost:9001&lt;/value&gt;</div><div class="line">		&lt;description&gt;The address of JobTracker&lt;/description&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p>注意hadoop-2.6.4/etc/hadoop目录下是没有mapred-site.xml文件的，只有mapred-site.xml.temple。我们需要把该文件复制一份，并命令为mapred-site.xml。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp mapred-site.xml.tmple mapred-site.xml</div></pre></td></tr></table></figure></p>
<h2 id="安装HDFS"><a href="#安装HDFS" class="headerlink" title="安装HDFS"></a>安装HDFS</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop namenode -format</div></pre></td></tr></table></figure>
<p>在Hadoop目录内输入以上命令。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>运行hadoop-2.6.4/sbin目录下的start-all.sh脚本。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./start-all.sh</div></pre></td></tr></table></figure></p>
<p>输入命令<code>jps</code>验证是否成功运行Hadoop。<br>在本机上出现如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">30417 SecondaryNameNode</div><div class="line">30610 Jps</div><div class="line">30324 DataNode</div><div class="line">30571 NodeManager</div><div class="line">29660 ResourceManager</div><div class="line">30253 NameNode</div></pre></td></tr></table></figure></p>
<p>说明Hadoop已经成功运行。</p>
<p>运行自带的例子验证。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop jar <span class="variable">$HADOOP_HOME</span>/share/hadoop/madreduce/hadoop-mapreduce-examples-2.6.4.jar pi 10 100</div></pre></td></tr></table></figure></p>
<p>出现以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Number of Maps  = 10</div><div class="line">Samples per Map = 100</div><div class="line">Wrote input for Map #0</div><div class="line">Wrote input for Map #1</div><div class="line">Wrote input for Map #2</div><div class="line">Wrote input for Map #3</div><div class="line">Wrote input for Map #4</div><div class="line">Wrote input for Map #5</div><div class="line">Wrote input for Map #6</div><div class="line">Wrote input for Map #7</div><div class="line">Wrote input for Map #8</div><div class="line">Wrote input for Map #9</div><div class="line">Starting Job</div><div class="line">……</div><div class="line">Job Finished in 1.749 seconds</div><div class="line">Estimated value of Pi is 3.14800000000000000000</div></pre></td></tr></table></figure></p>
<p>说明自带的例子hadoop-mapreduce-examples-2.6.4.jar已经成功运行，至此确认Hadoop已经成功安装。</p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hadoop：是一个由Apache基金会所开发的处理计算机集群上大数据的开源分布式系统基础框架。&lt;br&gt;本文基于Mac OSX 10.11操作系统和Hadoop 2.6.4。&lt;/p&gt;
    
    </summary>
    
      <category term="hadoop" scheme="http://aidaiz.com/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="http://aidaiz.com/tags/hadoop/"/>
    
      <category term="java" scheme="http://aidaiz.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>容量失效（capacity miss）与冲突失效（conflict miss）的区别</title>
    <link href="http://aidaiz.com/cache_miss_type/"/>
    <id>http://aidaiz.com/cache_miss_type/</id>
    <published>2015-12-10T08:26:02.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Cache访问失效分为强制性失效/冷失效（compulsory miss/cold miss）、容量失效（capacity miss）和冲突失效（conflict miss）。其中容量失效和冲突失效概念非常相近，理解起来不容易区别。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/cache_miss_type" target="_blank" rel="external">容量失效（capacity miss）与冲突失效（conflict miss）的区别</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#97;&#105;&#x64;&#97;&#105;&#x7a;&#x79;&#x79;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;">&#97;&#105;&#x64;&#97;&#105;&#x7a;&#x79;&#x79;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-12-10</a></strong></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul>
<li><strong>强制性失效：</strong>CPU第一次访问相应cache块，cache中肯定没有该cache块，引起的失效叫做强制性失效。这是不可避免的。</li>
<li><strong>容量失效：</strong>有限的cache容量导致cache放不下而替换出cache块，被替换出去的cache块再被访问，引起的失效叫做容量失效。</li>
<li><strong>冲突失效：</strong>在直接相联或组相联的cache中，不同的cache块由于index相同相互替换，引起的失效叫做冲突失效。</li>
</ul>
<p>#理解</p>
<p>如果两个cache块指向同一个cache位置，替换后，访问被替换cache块到底是属于容量失效还是冲突失效呢？<br>主要看当前cache的存储情况。<br>假设这里有32KB大小的直接相联cache。<br>情况一（容量失效）：如果有一个64KB大小的数组需要重复访问，数组的大小远远大于cache大小，没办法全部放入cache。第一次访问数组发生的失效全都是强制性失效。之后再访问数组，再发生的失效则全都是容量失效，这时cache已经存满，容量不足以存储全部数据。<br>情况二（冲突失效）：如果有两个8KB大小的数据需要来回访问，但是这两个数组都映射到相同的地址，cache大小足够存储全部的数据，但是因为相同地址发生了冲突需要来回替换，发生的失效则全都是冲突失效（第一次访问失效依旧是强制性失效），这时cache并没有存满。<br>避免容量失效只能通过增加cache大小实现，而避免冲突失效则可以通过提高相联度，优化替换策略，优化代码，增大cache容量等很多措施实现。</p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cache访问失效分为强制性失效/冷失效（compulsory miss/cold miss）、容量失效（capacity miss）和冲突失效（conflict miss）。其中容量失效和冲突失效概念非常相近，理解起来不容易区别。&lt;/p&gt;
    
    </summary>
    
      <category term="computer architecture" scheme="http://aidaiz.com/categories/computer-architecture/"/>
    
    
      <category term="cache" scheme="http://aidaiz.com/tags/cache/"/>
    
      <category term="computer architecture" scheme="http://aidaiz.com/tags/computer-architecture/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础入门(14)：权限控制</title>
    <link href="http://aidaiz.com/swift_14/"/>
    <id>http://aidaiz.com/swift_14/</id>
    <published>2015-07-29T03:28:32.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍Swift的基础知识：权限控制，包括公开访问（<em>pubilc</em>），内部访问（<em>internal</em>），私有访问（<em>private</em>）三种访问方式控制实体访问的权限。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/swift_14" target="_blank" rel="external">Swift基础入门(14)：权限控制</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#97;&#105;&#x64;&#97;&#x69;&#122;&#121;&#121;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;">&#97;&#105;&#x64;&#97;&#x69;&#122;&#121;&#121;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-07-29</a></strong></p>
<h1 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h1><p>我们可以给基本类型、常量变量、函数、类、结构体、枚举、属性、方法、下标等等设置访问级别确定访问权限。</p>
<ul>
<li>public：公开访问，实体能够被当前模块（<em>module</em>）中的所有源文件访问，也可以被其他引用了该模块的另一个模块中的所有源文件访问。</li>
<li>internal：内部访问，实体能够被当前模块中的所有源文件访问，但是不可以被其他引用了该模块的另一个模块中的源文件访问。</li>
<li>private：私有访问，实体只能在当前源文件中访问，不能被其他任何源文件访问。</li>
</ul>
<p>默认的权限为<code>internal</code>，<code>public</code>和<code>private</code>必须指定。</p>
<p>对于属性，可以设置取值权限比赋值权限更加开放，即getter的权限比setter高。<br>比如下面的例子，用<code>private(set)</code>把属性的setter权限设置为私有访问，而getter的权限仍然为默认的<code>internal</code>内部访问。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">// ListItem这个类，有两个公开的属性</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">String</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">var</span> isComplete: <span class="type">Bool</span></div><div class="line"></div><div class="line"><span class="comment">// 下面的代码表示把变量UUID的赋值权限设为private，对整个app可读，但值只能在本文件里写入</span></div><div class="line"><span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> <span class="type">UUID</span>: <span class="type">NSUUID</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">init</span>(text: <span class="type">String</span>, completed: <span class="type">Bool</span>, <span class="type">UUID</span>: <span class="type">NSUUID</span>) &#123;</div><div class="line">    <span class="keyword">self</span>.text = text</div><div class="line">    <span class="keyword">self</span>.isComplete = completed</div><div class="line">    <span class="keyword">self</span>.<span class="type">UUID</span> = <span class="type">UUID</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这段没有特别标记权限，因此属于默认的internal级别。在框架目标内可用，但对于其他目标不可用</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">refreshIdentity</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">self</span>.<span class="type">UUID</span> = <span class="type">NSUUID</span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">isEqual</span><span class="params">(object: AnyObject?)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> item = object <span class="keyword">as</span>? <span class="type">ListItem</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.<span class="type">UUID</span> == item.<span class="type">UUID</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍Swift的基础知识：权限控制，包括公开访问（&lt;em&gt;pubilc&lt;/em&gt;），内部访问（&lt;em&gt;internal&lt;/em&gt;），私有访问（&lt;em&gt;private&lt;/em&gt;）三种访问方式控制实体访问的权限。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="http://aidaiz.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://aidaiz.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础入门(13)：高级运算符</title>
    <link href="http://aidaiz.com/swift_13/"/>
    <id>http://aidaiz.com/swift_13/</id>
    <published>2015-07-28T03:59:40.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍Swift的基础知识：高级运算符，包括位运算符，溢出运算符和运算符重载与自定义。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/swift_13" target="_blank" rel="external">Swift基础入门(13)：高级操作符</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#97;&#x69;&#x64;&#x61;&#105;&#122;&#x79;&#121;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;">&#97;&#x69;&#x64;&#x61;&#105;&#122;&#x79;&#121;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-07-28</a></strong></p>
<h1 id="高级操作符"><a href="#高级操作符" class="headerlink" title="高级操作符"></a>高级操作符</h1><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>Swift中位运算符和C语言基本一致，不再详细介绍。</p>
<ul>
<li>~：取反</li>
<li>&amp;：与</li>
<li>|：或</li>
<li>^：异或</li>
<li>&lt;&lt;：左移</li>
<li>>>：右移<br>左移右移同样分逻辑移位和算术移位</li>
</ul>
<h2 id="溢出运算符"><a href="#溢出运算符" class="headerlink" title="溢出运算符"></a>溢出运算符</h2><p>Swift默认不能溢出，如果故意要溢出必须采用溢出运算。</p>
<ul>
<li>&amp;+：溢出加法</li>
<li>&amp;-：溢出减法</li>
<li>&amp;*：溢出乘法</li>
<li>&amp;/：溢出除法</li>
<li>&amp;%：溢出求余<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> willOverflow = <span class="type">UInt8</span>.<span class="built_in">max</span></div><div class="line"><span class="comment">// willOverflow 等于UInt8的最大整数 255</span></div><div class="line">willOverflow = willOverflow &amp;+ <span class="number">1</span></div><div class="line"><span class="comment">// 此时 willOverflow 等于 0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> willUnderflow = <span class="type">UInt8</span>.<span class="built_in">min</span></div><div class="line"><span class="comment">// willUnderflow 等于UInt8的最小值0</span></div><div class="line">willUnderflow = willUnderflow &amp;- <span class="number">1</span></div><div class="line"><span class="comment">// 此时 willUnderflow 等于 255</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> signedUnderflow = <span class="type">Int8</span>.<span class="built_in">min</span></div><div class="line"><span class="comment">// signedUnderflow 等于最小的有符整数 -128</span></div><div class="line">signedUnderflow = signedUnderflow &amp;- <span class="number">1</span></div><div class="line"><span class="comment">// 此时 signedUnderflow 等于 127</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> x = <span class="number">1</span></div><div class="line"><span class="keyword">let</span> y = x &amp;/ <span class="number">0</span></div><div class="line"><span class="comment">// y 等于 0</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>不一样的地方在于：一个数除以0或者对0求余数，即<code>i / 0</code>或者<code>i % 0</code>，其他默认会溢出的语言会报错。但是Swift的<code>i &amp;/ 0</code>和<code>i &amp;% 0</code>溢出运算会让结果都等于0。</p>
<h2 id="运算符函数"><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h2><p>对运算符重载，让已有的运算符，如<code>+</code>，<code>-</code>等基本运算符能对自定义的类和结构体进行运算。</p>
<ul>
<li>@infix：中置运算符</li>
<li>@prefix：前置运算符</li>
<li>@postfix：后置运算符</li>
<li>@assignment：组合赋值运算符<br>下面对<code>+</code>进行重载，函数传入了两个参数，表示双目运算符，有两个操作数。<br>函数前加上关键字<code>@infix</code>，表示<code>+</code>作为中置运算符，放在两个操作数的中间。<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2D</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"><span class="meta">@infix</span> <span class="function"><span class="keyword">func</span> + <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="keyword">left</span>.x + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>.y + <span class="keyword">right</span>.y)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> vector = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">1.0</span>)</div><div class="line"><span class="keyword">let</span> anotherVector = <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">4.0</span>)</div><div class="line"><span class="keyword">let</span> combinedVector = vector + anotherVector</div><div class="line"><span class="comment">// combinedVector 是一个新的Vector2D, 值为 (5.0, 5.0)</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>前置和后置运算分别加上关键字<code>@prefix</code>和<code>@postfix</code>，表示把运算符放在操作数前面或后面。<br>函数只传入一个参数，表示弹幕运算符，只有一个操作数。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@prefix</span> <span class="function"><span class="keyword">func</span> - <span class="params">(vector: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: -vector.x, y: -vector.y)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> positive = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</div><div class="line"><span class="keyword">let</span> negative = -positive</div><div class="line"><span class="comment">// negative 为 (-3.0, -4.0)</span></div><div class="line"><span class="keyword">let</span> alsoPositive = -negative</div><div class="line"><span class="comment">// alsoPositive 为 (3.0, 4.0)</span></div></pre></td></tr></table></figure></p>
<p>如果我们要重载<code>+=</code>，<code>-=</code>等运算符加上赋值符的组合赋值运算符，需要使用<code>@assignment</code>关键字。也可以和前置后置组合起来，形成<code>@prefix @assignment</code>或<code>@postfix @assignment</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@assignment <span class="function"><span class="keyword">func</span> += <span class="params">(<span class="keyword">inout</span> <span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> &#123;</div><div class="line">    <span class="keyword">left</span> = <span class="keyword">left</span> + <span class="keyword">right</span>		<span class="comment">//`+`在前面的例子中已经定义过了</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> original = <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>)</div><div class="line"><span class="keyword">let</span> vectorToAdd = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</div><div class="line">original += vectorToAdd</div><div class="line"><span class="comment">// original 现在为 (4.0, 6.0)</span></div><div class="line"></div><div class="line"><span class="meta">@prefix</span> @assignment <span class="function"><span class="keyword">func</span> ++ <span class="params">(<span class="keyword">inout</span> vector: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</div><div class="line">    vector += <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</div><div class="line">    <span class="keyword">return</span> vector</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> toIncrement = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</div><div class="line"><span class="keyword">let</span> afterIncrement = ++toIncrement</div><div class="line"><span class="comment">// toIncrement 现在是 (4.0, 5.0)</span></div><div class="line"><span class="comment">// afterIncrement 现在也是 (4.0, 5.0)</span></div></pre></td></tr></table></figure></p>
<p>比较运算符重载<code>==</code>和<code>!=</code>类似于其他中置运算符。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@infix</span> <span class="function"><span class="keyword">func</span> == <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">left</span>.x == <span class="keyword">right</span>.x) &amp;&amp; (<span class="keyword">left</span>.y == <span class="keyword">right</span>.y)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@infix</span> <span class="function"><span class="keyword">func</span> != <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> !(<span class="keyword">left</span> == <span class="keyword">right</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> twoThree = <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</div><div class="line"><span class="keyword">let</span> anotherTwoThree = <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</div><div class="line"><span class="keyword">if</span> twoThree == anotherTwoThree &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"这两个向量是相等的."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// prints "这两个向量是相等的."</span></div></pre></td></tr></table></figure></p>
<p>但是默认赋值符<code>=</code>和三目条件运算符<code>a?b:c</code>都不可重载。</p>
<ul>
<li>自定义运算符<br>除了标准的运算符之外，Swift还规定对只有<code>/ = - + * / &lt; &gt; ! &amp; | ^ . ~</code>这些符号的运算符进行自定义。<br>新的运算符需要在全局域用<code>operator</code>关键字声明，声明为中置，前置或后置。<br>比如<code>operator prefix +++ {}</code>声明了新的前置运算符<code>+++</code>。<br>然后重载实现<code>+++</code>运算符：<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@prefix</span> @assignment <span class="function"><span class="keyword">func</span> +++ <span class="params">(<span class="keyword">inout</span> vector: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</div><div class="line">    vector += vector</div><div class="line">    <span class="keyword">return</span> vector</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> toBeDoubled = <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">4.0</span>)</div><div class="line"><span class="keyword">let</span> afterDoubling = +++toBeDoubled</div><div class="line"><span class="comment">// toBeDoubled 现在是 (2.0, 8.0)</span></div><div class="line"><span class="comment">// afterDoubling 现在也是 (2.0, 8.0)</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>还可以为自定义的运算符定义结合性和优先级。<br>结合性<code>associativity</code>后面可以接<code>left</code>（和左边操作数结合），<code>right</code>（和右边操作数结合），<code>none</code>（默认值，不与其他相同优先级的运算符写在一起）。<br>优先级<code>precedence</code>后面接数值表示优先级，默认为<code>100</code>。<br>下面一个例子。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">operator</span> <span class="keyword">infix</span> +- &#123; <span class="keyword">associativity</span> <span class="keyword">left</span> <span class="keyword">precedence</span> <span class="number">140</span> &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> +- <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="keyword">left</span>.x + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>.y - <span class="keyword">right</span>.y)</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> firstVector = <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>)</div><div class="line"><span class="keyword">let</span> secondVector = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</div><div class="line"><span class="keyword">let</span> plusMinusVector = firstVector +- secondVector</div><div class="line"><span class="comment">// plusMinusVector 此时的值为 (4.0, -2.0)</span></div></pre></td></tr></table></figure></p>
<p>自定义运算符优先级默认为100，其他标准运算符优先级从高到低：</p>
<ul>
<li>160（无结合）：<code>&lt;&lt;</code>  <code>&gt;&gt;</code></li>
<li>150（左结合）：<code>*</code>  <code>/</code>  <code>%</code>  <code>&amp;*</code>  <code>&amp;/</code>  <code>&amp;%</code>  <code>&amp;</code>（位与）</li>
<li>140（左结合）：<code>+</code>  <code>-</code>  <code>&amp;+</code>  <code>&amp;-</code>  <code>|</code>（位或）  <code>^</code>（位异或）</li>
<li>135（无结合）：<code>..&lt;</code>  <code>...</code></li>
<li>132（无结合）：<code>is</code>  <code>as</code></li>
<li>130（无结合）：<code>&lt;</code>  <code>&lt;=</code>  <code>\&gt;</code>  <code>\&gt;=</code>  <code>==</code>  <code>!=</code>  <code>===</code>  <code>!==</code>  <code>~=</code>（模式匹配）</li>
<li>120（左结合）：<code>&amp;&amp;</code>（逻辑与）</li>
<li>110（左结合）：<code>||</code>（逻辑或）</li>
<li>100（右结合）：<code>? :</code> （三元条件）</li>
<li>90（右结合）：<code>=</code>  <code>*=</code>  <code>/=</code>  <code>%=</code>  <code>+=</code>  <code>-=</code>  <code>&lt;&lt;=</code>  <code>&gt;&gt;=</code>  <code>&amp;=</code>  <code>|=</code>  <code>^=</code>  <code>&amp;&amp;=</code>  <code>||=</code></li>
</ul>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍Swift的基础知识：高级运算符，包括位运算符，溢出运算符和运算符重载与自定义。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="http://aidaiz.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://aidaiz.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础入门(12)：泛型</title>
    <link href="http://aidaiz.com/swift_12/"/>
    <id>http://aidaiz.com/swift_12/</id>
    <published>2015-07-28T02:34:05.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍Swift的基础知识：泛型，适合任何类型的函数和类型。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/swift_12" target="_blank" rel="external">Swift基础入门(12)：泛型</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#97;&#x69;&#100;&#x61;&#x69;&#122;&#x79;&#x79;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;">&#97;&#x69;&#100;&#x61;&#x69;&#122;&#x79;&#x79;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-07-28</a></strong></p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型（<em>generic</em>）类似于C++中的模板，可以写出适合任何类型的函数和类型。为函数或者类型指定了模板类型，可以传入任何类型去替代模板类型。</p>
<h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;T&gt;<span class="params">(<span class="keyword">inout</span> a: T, <span class="keyword">inout</span> b: T)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> temporaryA = a</div><div class="line">    a = b</div><div class="line">    b = temporaryA</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></div><div class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></div><div class="line">swapTwoValues(&amp;someInt, &amp;anotherInt)</div><div class="line"><span class="comment">// someInt is now 107, and anotherInt is now 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> someString = <span class="string">"hello"</span></div><div class="line"><span class="keyword">var</span> anotherString = <span class="string">"world"</span></div><div class="line">swapTwoValues(&amp;someString, &amp;anotherString)</div><div class="line"><span class="comment">// someString is now "world", and anotherString is now "hello"</span></div></pre></td></tr></table></figure>
<p>函数<code>swapTwoValues</code>后面接尖括号和占位符<code>T</code>替代任何类型，函数的两个参数<code>a</code>和<code>b</code>的类型都指定为<code>T</code>，代表这两个参数类型是一样的，但是没有被确定，适合任何类型。<br>第7-10行，传入了两个整数，可以调用函数；第12-15行，传入了两个字符串，可以调用函数。</p>
<h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">var</span> items = [<span class="type">T</span>]()</div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: T)</span></span> &#123;</div><div class="line">        items.append(item)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</div><div class="line">        <span class="keyword">return</span> items.removeLast()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> stackOfStrings = <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</div><div class="line">stackOfStrings.push(<span class="string">"uno"</span>)</div><div class="line">stackOfStrings.push(<span class="string">"dos"</span>)</div><div class="line">stackOfStrings.push(<span class="string">"tres"</span>)</div><div class="line">stackOfStrings.push(<span class="string">"cuatro"</span>)</div><div class="line"><span class="comment">// 现在栈已经有4个string了</span></div></pre></td></tr></table></figure>
<p>结构体<code>Stack</code>被定义为泛型类型，传入参数T表示类型，比如<code>Stack&lt;String&gt;</code>。</p>
<h2 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h2><p>类型参数可以有多个，在尖括号中用逗号隔开。<br>类型参数的命名可以自由命名，以大写字母开头。<br>类型参数也可以定义类型约束。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>&lt;T: SomeClass, U: SomeProtocol&gt;<span class="params">(someT: T, someU: U)</span></span> &#123;</div><div class="line">    <span class="comment">// function body goes here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>比如上面代码中，类型<code>T</code>必须是类<code>SomeClass</code>的子类，类型<code>U</code>必须遵循协议<code>SomeProtocol</code>。<br>再来一个例子。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findIndex</span>&lt;T: Equatable&gt;<span class="params">(array: T[], valueToFind: T)</span></span> -&gt; <span class="type">Int</span>? &#123;</div><div class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> <span class="built_in">enumerate</span>(array) &#123;</div><div class="line">        <span class="keyword">if</span> value == valueToFind &#123;</div><div class="line">            <span class="keyword">return</span> index</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Equatable</code>是Swift自带的协议，表示可以用<code>==</code>和<code>!=</code>进行比较，所有的标准类型都支持这个协议。因为后面的函数体中出现了<code>==</code>比较，所以必须要求类型<code>T</code>遵循<code>Equatable</code>类型。</p>
<h2 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h2><p>关联类型（<em>associated type</em>）声明在协议中，表示一个类型，但协议被实现前不需要指定具体类型。<br>下面的例子声明了一个协议<code>Container</code>，表示容器，并定义了<code>append</code>方法，<code>count</code>属性和下标。<code>append</code>方法需要传入一个参数，为了使协议能支持任何类型，传入的参数类型不确定，因此用关联类型<code>ItemType</code>替代，使用关键字<code>typealias</code>，这里不是别名的意思。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</div><div class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span></div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: ItemType)</span></span></div><div class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>声明协议之后，实现这个协议。<br>把关联类型声明成<code>Int</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntStack</span>: <span class="title">Container</span> </span>&#123;</div><div class="line">    <span class="comment">// IntStack的原始实现</span></div><div class="line">    <span class="keyword">var</span> items = [<span class="type">Int</span>]()</div><div class="line">    <span class="comment">// 遵循Container协议的实现</span></div><div class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span> = <span class="type">Int</span></div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: Int)</span></span> &#123;</div><div class="line">        <span class="keyword">self</span>.push(item)</div><div class="line">    &#125;</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以把关联类型声明成泛型类型：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt;: <span class="title">Container</span> </span>&#123;</div><div class="line">    <span class="comment">// original Stack&lt;T&gt; implementation</span></div><div class="line">    <span class="keyword">var</span> items = [<span class="type">T</span>]()</div><div class="line">    <span class="comment">// conformance to the Container protocol</span></div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: T)</span></span> &#123;</div><div class="line">        <span class="keyword">self</span>.push(item)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里没有定义<code>typealias ItemType</code>的类型，因为通过<code>append()</code>传入的参数就可以判断<code>ItemType</code>的类型，可以省略定义。</p>
<ul>
<li>参数约束<br>通常对关联类型定义约束，使用<code>where</code>语句定义参数的约束，紧跟在类型参数列表后面。<br>下面一个例子。<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">allItemsMatch</span>&lt;</span></div><div class="line">    C1: Container, C2: Container</div><div class="line">    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;</div><div class="line">    <span class="params">(someContainer: C1, anotherContainer: C2)</span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 检查两个Container的元素个数是否相同</span></div><div class="line">        <span class="keyword">if</span> someContainer.<span class="built_in">count</span> != anotherContainer.<span class="built_in">count</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 检查两个Container相应位置的元素彼此是否相等</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;someContainer.<span class="built_in">count</span> &#123;</div><div class="line">            <span class="keyword">if</span> someContainer[i] != anotherContainer[i] &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 如果所有元素检查都相同则返回true</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>两个类型参数<code>C1</code>和<code>C2</code>都遵循协议<code>Container</code>，紧跟<code>where</code>语句，表示<code>C1</code>的参数和<code>C2</code>的参数必须是同一个类型，且可以使用<code>==</code>或者<code>=!</code>符号。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stackOfStrings = <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</div><div class="line">stackOfStrings.push(<span class="string">"uno"</span>)</div><div class="line">stackOfStrings.push(<span class="string">"dos"</span>)</div><div class="line">stackOfStrings.push(<span class="string">"tres"</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> arrayOfStrings = [<span class="string">"uno"</span>, <span class="string">"dos"</span>, <span class="string">"tres"</span>]</div><div class="line"></div><div class="line"><span class="keyword">if</span> allItemsMatch(stackOfStrings, arrayOfStrings) &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"All items match."</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Not all items match."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 输出 "All items match."</span></div></pre></td></tr></table></figure></p>
<p>这个函数的作用是比较两个容器的元素是否完全一样。</p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍Swift的基础知识：泛型，适合任何类型的函数和类型。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="http://aidaiz.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://aidaiz.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础入门(11)：扩展和协议</title>
    <link href="http://aidaiz.com/swift_11/"/>
    <id>http://aidaiz.com/swift_11/</id>
    <published>2015-07-24T08:28:22.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍Swift的基础知识：扩展（<em>extensions</em>）和协议（<em>protocol</em>）的语法和实例。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/swift_11" target="_blank" rel="external">Swift基础入门(11)：扩展和协议</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x61;&#x69;&#x64;&#97;&#x69;&#x7a;&#121;&#x79;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;">&#x61;&#x69;&#x64;&#97;&#x69;&#x7a;&#121;&#x79;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-07-27</a></strong></p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>扩展可以为枚举，类和结构体：</p>
<ul>
<li>添加计算型实例属性和计算型类型属性</li>
<li>添加实例方法和类型方法</li>
<li>添加构造器</li>
<li>添加下标</li>
<li>添加新的嵌套类型</li>
<li>已有类型适配协议</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>声明扩展使用关键字<code>extension</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">extension SomeType &#123;</div><div class="line">    // 新功能</div><div class="line">&#125;</div><div class="line"></div><div class="line">extension SomeType: SomeProtocol, AnotherProtocol &#123;</div><div class="line">    // 已有类型适配的协议实现</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h2><p>扩展只能添加计算型属性，包括实例属性和类型属性，但是不能添加存储属性和属性观察器。<br>下面的例子为<code>Double</code>类添加了5个计算型实例属性，因为都是只读属性，所以省略了<code>get</code>关键字。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> * <span class="number">1_000.0</span> &#125;</div><div class="line">    <span class="keyword">var</span> m : <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</div><div class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">100.0</span> &#125;</div><div class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">1_000.0</span> &#125;</div><div class="line">    <span class="keyword">var</span> ft: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">3.28084</span> &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> oneInch = <span class="number">25.4</span>.mm</div><div class="line"><span class="built_in">println</span>(<span class="string">"One inch is \(oneInch) meters"</span>)</div><div class="line"><span class="comment">// 打印输出："One inch is 0.0254 meters"</span></div><div class="line"><span class="keyword">let</span> threeFeet = <span class="number">3</span>.ft</div><div class="line"><span class="built_in">println</span>(<span class="string">"Three feet is \(threeFeet) meters"</span>)</div><div class="line"><span class="comment">// 打印输出："Three feet is 0.914399970739201 meters"</span></div></pre></td></tr></table></figure></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>下面的例子为<code>Int</code>类型添加了1个实例方法，实现了多次执行某任务的功能。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">repetitions</span><span class="params">(task: <span class="params">()</span></span></span> -&gt; ()) &#123;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="keyword">self</span> &#123;</div><div class="line">            task()</div><div class="line">&#125;&#125;&#125;</div><div class="line"></div><div class="line"><span class="number">3</span>.repetitions(&#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Hello!"</span>)</div><div class="line">    &#125;)</div><div class="line"><span class="comment">// Hello!</span></div><div class="line"><span class="comment">// Hello!</span></div><div class="line"><span class="comment">// Hello!</span></div></pre></td></tr></table></figure></p>
<p>这个实例方法传入一个无参数无返回值的函数，没有返回值。</p>
<p>扩展的方法可以修改实例本身，使用<code>mutating</code>关键字。<br>下面的例子添加了一个实现平方计算的方法。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">self</span> = <span class="keyword">self</span> * <span class="keyword">self</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></div><div class="line">someInt.square()</div><div class="line"><span class="comment">// someInt 现在值是 9</span></div></pre></td></tr></table></figure></p>
<p>枚举和结构体修改<code>self</code>或者属性的方法都必须标注为<code>mutating</code>。</p>
<h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p>下面的例子为<code>Int</code>类型添加了1个下标，返回整数的从右数第<code>index</code>位上的个位数。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="keyword">subscript</span>(<span class="keyword">var</span> digitIndex: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">var</span> decimalBase = <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> digitIndex &gt; <span class="number">0</span> &#123;</div><div class="line">                decimalBase *= <span class="number">10</span></div><div class="line">                --digitIndex</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">self</span> / decimalBase) % <span class="number">10</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="number">746381295</span>[<span class="number">0</span>]</div><div class="line"><span class="comment">// returns 5</span></div><div class="line"><span class="number">746381295</span>[<span class="number">1</span>]</div><div class="line"><span class="comment">// returns 9</span></div><div class="line"><span class="number">746381295</span>[<span class="number">2</span>]</div><div class="line"><span class="comment">// returns 2</span></div><div class="line"><span class="number">746381295</span>[<span class="number">8</span>]</div><div class="line"><span class="comment">// returns 7</span></div></pre></td></tr></table></figure></p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>扩展只能添加便利构造器，但是不能添加指定构造器和析构函数。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</div><div class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Rect</span> </span>&#123;</div><div class="line">    <span class="keyword">init</span>(center: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</div><div class="line">        <span class="keyword">let</span> originX = center.x - (size.width / <span class="number">2</span>)</div><div class="line">        <span class="keyword">let</span> originY = center.y - (size.height / <span class="number">2</span>)</div><div class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> centerRect = <span class="type">Rect</span>(center: <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">4.0</span>),</div><div class="line">    size: <span class="type">Size</span>(width: <span class="number">3.0</span>, height: <span class="number">3.0</span>))</div><div class="line"><span class="comment">// centerRect的原点是 (2.5, 2.5)，大小是 (3.0, 3.0)</span></div></pre></td></tr></table></figure></p>
<p>上面的例子为类<code>Rect</code>添加了构造器，传入<code>Point</code>和<code>Size</code>参数，初始化了<code>Rect</code>。</p>
<h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>扩展可以向已有的枚举，类和结构体添加新的嵌套类型。<br>下面的例子为<code>Character</code>添加了新的枚举类型：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Character</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Kind</span> </span>&#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Vowel</span>, <span class="type">Consonant</span>, <span class="type">Other</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> kind: <span class="type">Kind</span> &#123;</div><div class="line">        <span class="keyword">switch</span> <span class="type">String</span>(<span class="keyword">self</span>).lowercaseString &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"u"</span>:</div><div class="line">            <span class="keyword">return</span> .<span class="type">Vowel</span></div><div class="line">        <span class="keyword">case</span> <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>, <span class="string">"m"</span>,</div><div class="line">             <span class="string">"n"</span>, <span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">"v"</span>, <span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>:</div><div class="line">            <span class="keyword">return</span> .<span class="type">Consonant</span></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> .<span class="type">Other</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printLetterKinds</span><span class="params">(word: String)</span></span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"'\(word)' is made up of the following kinds of letters:"</span>)</div><div class="line">    <span class="keyword">for</span> character <span class="keyword">in</span> word &#123;</div><div class="line">        <span class="keyword">switch</span> character.kind &#123;</div><div class="line">        <span class="keyword">case</span> .<span class="type">Vowel</span>:</div><div class="line">            <span class="built_in">print</span>(<span class="string">"vowel "</span>)</div><div class="line">        <span class="keyword">case</span> .<span class="type">Consonant</span>:</div><div class="line">            <span class="built_in">print</span>(<span class="string">"consonant "</span>)</div><div class="line">        <span class="keyword">case</span> .<span class="type">Other</span>:</div><div class="line">            <span class="built_in">print</span>(<span class="string">"other "</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\n"</span>)</div><div class="line">&#125;</div><div class="line">printLetterKinds(<span class="string">"Hello"</span>)</div><div class="line"><span class="comment">// 'Hello' is made up of the following kinds of letters:</span></div><div class="line"><span class="comment">// consonant vowel consonant consonant vowel</span></div></pre></td></tr></table></figure></p>
<p>枚举类型<code>Kind</code>表示字母是元音，辅音还是其他类型。<br>添加了计算型方法，返回字母对应的<code>Kind</code>枚举成员类型。</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>协议类似于C++/Java语言中的接口，定义要实现的属性方法，但是不实现，由继承的枚举，结构体和类去实现。</p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// 协议内容</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span>: <span class="title">FirstProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// 结构体内容</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">SomeSuperClass</span>, <span class="title">FirstProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// 类的内容</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结构体<code>SomeStructure</code>实现（用<code>:</code>表示）协议<code>someProtocol</code>和<code>AnotherProtocol</code>，多个协议隔开用<code>,</code>表示，需要实现协议的所有属性和方法。<br>类<code>SomeClass</code>实现父类<code>SomeSuperClass</code>和两个协议，需要把父类声明写到前面，协议并列写在后面。</p>
<ul>
<li>协议类型<br>协议也可以作为一种基本类型，作为函数方法的参数类型、返回值类型，常量变量属性的类型，数组字典等集合的元素类型等等。<br>当协议作为集合的元素类型时，遍历集合得到的实例是协议类型，只能访问属于协议中定义的属性方法下标。</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>协议中声明的属性，可以实现为实例属性或类型属性，存储型属性或计算型属性都可以。<br>协议中的只读属性，可以实现为只读属性或读写属性；但是协议中的读写属性，只能实现为读写属性。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> mustBeSettable : <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;	<span class="comment">//读写属性</span></div><div class="line">    <span class="keyword">var</span> doesNotNeedToBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;	<span class="comment">//只读属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>协议中可以定义类型属性，只能实现为类型属性，属性前加上关键字<code>static</code>。<br>枚举和结构体实现后要在属性前加上关键字<code>static</code>，但是类实现后要在属性前加上关键字<code>class</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AnotherProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> someTypeProperty: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面一个实例。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">FullyNamed</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">FullyNamed</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> john = <span class="type">Person</span>(fullName: <span class="string">"John Appleseed"</span>)</div><div class="line"><span class="comment">//john.fullName 为 "John Appleseed"</span></div></pre></td></tr></table></figure></p>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>协议中的方法不需要大括号和具体实现，支持变长参数，而不支持参数默认值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RandomNumberGenerator</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span> -&gt; <span class="type">Double</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和类型属性一样，类型方法也是在协议中使用<code>static</code>，枚举和结构体中用<code>static</code>继承，而类中用<code>class</code>继承。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">someTypeMethod</span>()</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>变异方法<br>在<code>func</code>前加上关键字<code>mutating</code>的方法表示在该方法中可以修改实例及其属性的值，称为变异（<em>mutating</em>）方法。<br>枚举和结构体实现时，需要加上<code>mutating</code>关键字；而类实现时，不需要加上<code>mutating</code>关键字。<br>下面一个实例。<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Togglable</span> </span>&#123;</div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">toggle</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OnOffSwitch</span>: <span class="title">Togglable</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Off</span>, <span class="type">On</span></div><div class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">toggle</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Off</span>:</div><div class="line">            <span class="keyword">self</span> = <span class="type">On</span></div><div class="line">        <span class="keyword">case</span> <span class="type">On</span>:</div><div class="line">            <span class="keyword">self</span> = <span class="type">Off</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> lightSwitch = <span class="type">OnOffSwitch</span>.<span class="type">Off</span></div><div class="line">lightSwitch.toggle()</div><div class="line"><span class="comment">//lightSwitch 现在的值为 .On</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>在<code>func toggle()</code>中，修改了<code>self</code>的值，属于变异方法。</p>
<h2 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h2><p>协议中的构造器不需要大括号和具体实现。<br>类实现协议时，必须给构造器前面加上关键字<code>required</code>，表示它的子类必须继承的构造器。<br>当然，如果针对<code>final</code>类就不需要加<code>required</code>了，标有关键字<code>final</code>的类表示不能有子类。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">init</span>(someParameter: <span class="type">Int</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">SomeProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(someParameter: <span class="type">Int</span>) &#123;</div><div class="line">        <span class="comment">//构造器实现</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有一种情况，如果子类重写了父类的指定构造器，需要在构造器前加上<code>override</code>，但是如果又要同时实现协议，需要在构造器前加上<code>required</code>，那么<code>required</code>应该放在<code>override</code>前面。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubClass</span>: <span class="title">SomeSuperClass</span>, <span class="title">SomeProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// "required" from SomeProtocol conformance; "override" from SomeSuperClass</span></div><div class="line">    <span class="keyword">required</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="comment">// 构造器实现</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>可失败构造器<br>协议中的可失败构造器可以实现成可失败构造器或非可失败构造器；而协议中的非可失败构造器只能实现成非可失败构造器或隐式解析类型的可失败构造器（<code>init!</code>）。</li>
</ul>
<h2 id="适配协议"><a href="#适配协议" class="headerlink" title="适配协议"></a>适配协议</h2><p>扩展可以对已存在的枚举，结构体和类添加成员，比如属性，方法，下标，协议等。<br>下面的例子展示了通过扩展为已有类型适配协议。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TextRepresentable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">asText</span><span class="params">()</span></span> -&gt; <span class="type">String</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dice</span>: <span class="title">TextRepresentable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">asText</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"A \(sides)-sided dice"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Dice</code>是一个已存在的类型，协议中的<code>asText</code>方法被添加实现在了<code>Dice</code>中。<br>如果<code>Dice</code>已经存在了<code>asText() -&gt; String</code>方法，可以直接<code>extension Dice: TextRepresentable {}</code>，添加实现协议的声明。</p>
<h2 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h2><p>协议也可以和类一样，继承别的协议。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">InheritingProtocol</span>: <span class="title">SomeProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// 协议定义</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>类专属协议<br>如果在继承列表中加上<code>class</code>，且<code>class</code>必须第一个被声明，其他继承协议在后面并列声明，则表示这个协议只能由类实现，枚举和结构体不可以实现。<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeClassOnlyProtocol</span>: <span class="title">class</span>, <span class="title">SomeInheritedProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// class-only protocol definition goes here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="协议合成"><a href="#协议合成" class="headerlink" title="协议合成"></a>协议合成</h2><p>多个协议可以用protcol<someprotocol, anotherprotocol="">的格式临时组合成一个协议。<br>下面一个例子。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Named</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Aged</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">Named</span>, <span class="title">Aged</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">wishHappyBirthday</span><span class="params">(celebrator: <span class="keyword">protocol</span>&lt;Named, Aged&gt;)</span></span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Happy birthday \(celebrator.name) - you're \(celebrator.age)!"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> birthdayPerson = <span class="type">Person</span>(name: <span class="string">"Malcolm"</span>, age: <span class="number">21</span>)</div><div class="line">wishHappyBirthday(birthdayPerson)</div><div class="line"><span class="comment">// 输出 "Happy birthday Malcolm - you're 21!</span></div></pre></td></tr></table></figure></someprotocol,></p>
<h2 id="协议一致性"><a href="#协议一致性" class="headerlink" title="协议一致性"></a>协议一致性</h2><p>用<code>is</code>操作符检查协议是否实现了特定协议，返回<code>true</code>或<code>false</code>。<br>用<code>as?</code>操作符返回一个可选值，如果协议实现了特定协议，返回协议类型；否则返回<code>nil</code>。如果这个协议一定实现了特定协议，可以用<code>as!</code>强制返回非可选的特定类型。<br>下面一个例子。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HasArea</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>: <span class="title">HasArea</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> pi = <span class="number">3.1415927</span></div><div class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></div><div class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">return</span> pi * radius * radius &#125;</div><div class="line">    <span class="keyword">init</span>(radius: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.radius = radius &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span>: <span class="title">HasArea</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> area: <span class="type">Double</span></div><div class="line">    <span class="keyword">init</span>(area: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.area = area &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> legs: <span class="type">Int</span></div><div class="line">    <span class="keyword">init</span>(legs: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.legs = legs &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> objects: [<span class="type">AnyObject</span>] = [</div><div class="line">    <span class="type">Circle</span>(radius: <span class="number">2.0</span>),</div><div class="line">    <span class="type">Country</span>(area: <span class="number">243_610</span>),</div><div class="line">    <span class="type">Animal</span>(legs: <span class="number">4</span>)</div><div class="line">]</div><div class="line"></div><div class="line"><span class="keyword">for</span> object <span class="keyword">in</span> objects &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> objectWithArea = object <span class="keyword">as</span>? <span class="type">HasArea</span> &#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"Area is \(objectWithArea.area)"</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"Something that doesn't have an area"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Area is 12.5663708</span></div><div class="line"><span class="comment">// Area is 243610.0</span></div><div class="line"><span class="comment">// Something that doesn't have an area</span></div></pre></td></tr></table></figure></p>
<p>类<code>Circle</code>和类<code>Country</code>都实现了<code>HasArea</code>协议，而类<code>Animal</code>没有实现<code>HasArea</code>协议。<br>这三个类的实例用同一个数组装上，然后遍历，利用协议一致性检查。在这个数组中实例的值的类型没有变，但是这里显式为<code>HasArea</code>类型，所以只能访问<code>area</code>属性。</p>
<h2 id="可选协议"><a href="#可选协议" class="headerlink" title="可选协议"></a>可选协议</h2><p>可选类型可以含有可选成员，可以选择是否实现这些可选成员，用关键字<code>optional</code>来表示这些可选成员。可选协议在调用时可以使用可选链。<br>协议前的<code>@objc</code>表示协议是可选的，也表示暴露给<code>Objective-C</code>的代码，只对类有效。所以可选协议只能由类实现。<br>下面一个例子。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">CounterDataSource</span> </span>&#123;</div><div class="line">    <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">incrementForCount</span><span class="params">(<span class="built_in">count</span>: Int)</span></span> -&gt; <span class="type">Int</span></div><div class="line">    <span class="keyword">optional</span> <span class="keyword">var</span> fixedIncrement: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> dataSource: <span class="type">CounterDataSource</span>?</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> amount = dataSource?.incrementForCount?(<span class="built_in">count</span>) &#123;</div><div class="line">            <span class="built_in">count</span> += amount</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> amount = dataSource?.fixedIncrement? &#123;</div><div class="line">            <span class="built_in">count</span> += amount</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//为协议实现可选属性</span></div><div class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSource</span>: <span class="title">CounterDataSource</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> fixedIncrement = <span class="number">3</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> counter = <span class="type">Counter</span>()</div><div class="line">counter.dataSource = <span class="type">ThreeSource</span>()</div><div class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">4</span> &#123;</div><div class="line">    counter.increment()</div><div class="line">    <span class="built_in">print</span>(counter.<span class="built_in">count</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="comment">// 6</span></div><div class="line"><span class="comment">// 9</span></div><div class="line"><span class="comment">// 12</span></div><div class="line"></div><div class="line"><span class="comment">//为协议实现可选方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TowardsZeroSource</span>: <span class="title">CounterDataSource</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementForCount</span><span class="params">(<span class="built_in">count</span>: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">0</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">count</span> &lt; <span class="number">0</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">counter.<span class="built_in">count</span> = -<span class="number">4</span></div><div class="line">counter.dataSource = <span class="type">TowardsZeroSource</span>()</div><div class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</div><div class="line">    counter.increment()</div><div class="line">    <span class="built_in">print</span>(counter.<span class="built_in">count</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// -3</span></div><div class="line"><span class="comment">// -2</span></div><div class="line"><span class="comment">// -1</span></div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 0</span></div></pre></td></tr></table></figure></p>
<h2 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h2><p>扩展协议可以为每个实现该协议的地方（<em>遵循者</em>）添加属性或方法的实现，该协议的遵循者不用任何修改，可以得到添加的属性方法。<br>这种方式可以为协议中的属性和方法提供默认的实现，遵循者中再次实现可以覆盖默认的实现。<br>扩展协议时可以限定条件，只有满足条件的遵循者能够得到协议扩展的属性和方法。</p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍Swift的基础知识：扩展（&lt;em&gt;extensions&lt;/em&gt;）和协议（&lt;em&gt;protocol&lt;/em&gt;）的语法和实例。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="http://aidaiz.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://aidaiz.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础入门(10)：类型转换</title>
    <link href="http://aidaiz.com/swift_10/"/>
    <id>http://aidaiz.com/swift_10/</id>
    <published>2015-07-24T07:23:06.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍Swift的基础知识：类型的检查和转换。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/swift_10" target="_blank" rel="external">Swift基础入门(10)：类型转换</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#97;&#x69;&#100;&#97;&#105;&#x7a;&#121;&#121;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;">&#97;&#x69;&#100;&#97;&#105;&#x7a;&#121;&#121;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-07-24</a></strong></p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="数值型类型转换"><a href="#数值型类型转换" class="headerlink" title="数值型类型转换"></a>数值型类型转换</h2><ul>
<li><p>Int，Double，Float：<br><code>Int16</code>与<code>Int8</code>不能直接相加，需要通过<code>Int16(Int8)</code>转换。同样，<code>Int8</code>，<code>UInt8</code>，<code>Int16</code>，<code>UInt16</code>，<code>Int32</code>，<code>UInt32</code>，<code>Int64</code>，<code>UInt64</code>都可以互相转换。<br><code>Double</code>与<code>Int</code>也不能相加，也需要通过<code>Double(Int)</code>转换，如果只需要整数部分，也可以通过<code>Int(Double)</code>转换。同样，<code>Float(Int)</code>，<code>Int(Float)</code>，<code>Double(Float)</code>，<code>Float(Double)</code>都可以互相转换</p>
</li>
<li><p>String，Int：<br>String-&gt;Int：<code>String.toInt()</code>函数可以把<code>String</code>转换成可选类型<code>Int?</code>，因为<code>String</code>中不一定能转换成<code>Int</code>，所以得到可选类型。<br>Int-&gt;String：<code>String(Int)</code>函数可以把<code>Int</code>转换成<code>String</code>。</p>
</li>
</ul>
<h2 id="类型检查和向下转换"><a href="#类型检查和向下转换" class="headerlink" title="类型检查和向下转换"></a>类型检查和向下转换</h2><p>类型检查用<code>is</code>操作符检查一个实例是否属于特定类型，返回<code>true</code>或者<code>false</code>。<br>基类类型用<code>as?</code>或者<code>as!</code>操作符转换成子类类型。因为转换可能失败，所以使用<code>as?</code>返回可选类型的子类类型；如果确定转换一定成功，可以使用<code>as!</code>强制返回非可选类型的子类类型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediaItem</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span>: <span class="title">MediaItem</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> director: <span class="type">String</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, director: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.director = director</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Song</span>: <span class="title">MediaItem</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> artist: <span class="type">String</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, artist: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.artist = artist</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> library = [</div><div class="line">    <span class="type">Movie</span>(name: <span class="string">"Casablanca"</span>, director: <span class="string">"Michael Curtiz"</span>),</div><div class="line">    <span class="type">Song</span>(name: <span class="string">"Blue Suede Shoes"</span>, artist: <span class="string">"Elvis Presley"</span>),</div><div class="line">    <span class="type">Movie</span>(name: <span class="string">"Citizen Kane"</span>, director: <span class="string">"Orson Welles"</span>),</div><div class="line">    <span class="type">Song</span>(name: <span class="string">"The One And Only"</span>, artist: <span class="string">"Chesney Hawkes"</span>),</div><div class="line">    <span class="type">Song</span>(name: <span class="string">"Never Gonna Give You Up"</span>, artist: <span class="string">"Rick Astley"</span>)</div><div class="line">]</div><div class="line"><span class="comment">// the type of "library" is inferred to be [MediaItem]</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> movieCount = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> songCount = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> library &#123;</div><div class="line">    <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Movie</span> &#123;</div><div class="line">        ++movieCount</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Song</span> &#123;</div><div class="line">        ++songCount</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">println</span>(<span class="string">"Media library contains \(movieCount) movies and \(songCount) songs"</span>)</div><div class="line"><span class="comment">// prints "Media library contains 2 movies and 3 songs"</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> library &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> movie = item <span class="keyword">as</span>? <span class="type">Movie</span> &#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"Movie: '\(movie.name)', dir. \(movie.director)"</span>)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> song = item <span class="keyword">as</span>? <span class="type">Song</span> &#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"Song: '\(song.name)', by \(song.artist)"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Movie: 'Casablanca', dir. Michael Curtiz</span></div><div class="line"><span class="comment">// Song: 'Blue Suede Shoes', by Elvis Presley</span></div><div class="line"><span class="comment">// Movie: 'Citizen Kane', dir. Orson Welles</span></div><div class="line"><span class="comment">// Song: 'The One And Only', by Chesney Hawkes</span></div><div class="line"><span class="comment">// Song: 'Never Gonna Give You Up', by Rick Astley</span></div></pre></td></tr></table></figure></p>
<p>类<code>Movie</code>和类<code>Song</code>都是继承自类<code>MediaItem</code>。<br>数组<code>Libray</code>自动判断类型为<code>MediaItem</code>，存入了两个<code>Movie</code>实例和三个<code>Song</code>实例。在<code>for-in</code>循环中遍历出来的都是基类类型，但它实际上存储的是子类类型。<br>第33-43行：<code>item is Movie</code>和<code>item is Song</code>判断<code>item</code>实际存储的值是不是子类类型，是的话在相应数量的记录上加1，最后输出各子类类型的数组元素的个数。<br>第45-56行：<code>item as? Movie</code>和<code>item as? Song</code>将<code>item</code>强制转换成子类类型，如果实际存储的不相符返回<code>nil</code>，实际存储的相符返回相应的子类类型，并打印相应信息。</p>
<h2 id="Any和AnyObject类型转换"><a href="#Any和AnyObject类型转换" class="headerlink" title="Any和AnyObject类型转换"></a>Any和AnyObject类型转换</h2><ul>
<li>Any：任意类型，包括方法类型。</li>
<li>AnyObject：任意class类型。<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> someObjects: [<span class="type">AnyObject</span>] = [</div><div class="line">    <span class="type">Movie</span>(name: <span class="string">"2001: A Space Odyssey"</span>, director: <span class="string">"Stanley Kubrick"</span>),</div><div class="line">    <span class="type">Movie</span>(name: <span class="string">"Moon"</span>, director: <span class="string">"Duncan Jones"</span>),</div><div class="line">    <span class="type">Movie</span>(name: <span class="string">"Alien"</span>, director: <span class="string">"Ridley Scott"</span>)</div><div class="line">]</div><div class="line"></div><div class="line"><span class="keyword">var</span> things = [<span class="type">Any</span>]()</div><div class="line">things.append(<span class="number">0</span>)</div><div class="line">things.append(<span class="number">0.0</span>)</div><div class="line">things.append(<span class="string">"hello"</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>someObject</code>是一个很多class类型组成的混合class类型数组，所以用<code>AnyObject</code>。<br><code>things</code>是一个很多类型组成的混合类型数组，所以用<code>Any</code>。<br>它们的访问都可以通过遍历，然后使用<code>is</code>判断或者<code>as</code>转换。</p>
<blockquote>
<p>在<code>switch</code>的<code>case</code>语句中，使用<code>as</code>而不是<code>as?</code>。因为<code>case</code>语句中类型的检查和转换总是安全的。</p>
</blockquote>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍Swift的基础知识：类型的检查和转换。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="http://aidaiz.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://aidaiz.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础入门(9)：可选链和自动引用计数</title>
    <link href="http://aidaiz.com/swift_9/"/>
    <id>http://aidaiz.com/swift_9/</id>
    <published>2015-07-23T07:43:48.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍Swift的基础知识：通过可选链（<em>optional chaining</em>）调用属性，方法和下标；自动引用计数（<em>automatic reference counting</em>）的工作机制；循环强引用的解决方案。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/swift_9" target="_blank" rel="external">Swift基础入门(9)：可选链自动引用计数</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#97;&#x69;&#100;&#x61;&#105;&#x7a;&#x79;&#121;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;">&#97;&#x69;&#100;&#x61;&#105;&#x7a;&#x79;&#121;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-07-24</a></strong></p>
<h1 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h1><p>如果请求和调用属性，方法和下标的目标可能为空<code>nil</code>，这样的多次请求或调用就可以被链接起来，称为可选链。<br>如果任何一个节点为空<code>nil</code>，整个可选链失效。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; <span class="comment">//人</span></div><div class="line">    <span class="keyword">var</span> residence: <span class="type">Residence</span>? <span class="comment">//每个人可能有住所</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Residence</span> </span>&#123; <span class="comment">//住所</span></div><div class="line">    <span class="keyword">var</span> id: <span class="type">String</span>? <span class="comment">//住所可能有ID</span></div><div class="line">    <span class="keyword">var</span> address: <span class="type">Address</span>? <span class="comment">//住所可能有地址</span></div><div class="line">    <span class="keyword">var</span> rooms = [<span class="type">Room</span>]() <span class="comment">//住所的房间</span></div><div class="line">    <span class="keyword">var</span> numberOfRooms: <span class="type">Int</span> &#123; <span class="comment">//返回住所的房间数量</span></div><div class="line">        <span class="keyword">return</span> rooms.<span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Room</span> &#123; <span class="comment">//下标地址访问住所的一个房间</span></div><div class="line">        <span class="keyword">return</span> rooms[i]</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printNumberOfRooms</span><span class="params">()</span></span> &#123; <span class="comment">//打印房间的数量</span></div><div class="line">        <span class="built_in">println</span>(<span class="string">"The number of rooms is \(numberOfRooms)"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getId</span><span class="params">()</span></span> -&gt; <span class="type">String</span>? &#123; <span class="comment">//返回住所的ID</span></div><div class="line">        <span class="keyword">if</span> id != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> id</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123; <span class="comment">//房间</span></div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span> <span class="comment">//房间的名字</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125; <span class="comment">//房间的构造器</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123; <span class="comment">//地址</span></div><div class="line">    <span class="keyword">var</span> street: <span class="type">String</span>? <span class="comment">//地址可能有街道</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> john = <span class="type">Person</span>()</div><div class="line"></div><div class="line"><span class="comment">//属性</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount = john.residence?.numberOfRooms &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"John's residence has \(roomCount) room(s)."</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Unable to retrieve the number of rooms."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "Unable to retrieve the number of rooms。</span></div><div class="line"></div><div class="line"><span class="comment">//无返回值方法</span></div><div class="line"><span class="keyword">if</span> john.residence?.printNumberOfRooms() != <span class="literal">nil</span>&#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"It was possible to print the number of rooms."</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"It was not possible to print the number of rooms."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "It was not possible to print the number of rooms."。</span></div><div class="line"></div><div class="line"><span class="comment">//有返回值方法</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> buildingId = john.residence?.getId() &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"John's building identifier is \(buildingId)."</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Unable to retrieve the ID of building."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "John's building identifier is The Larches."。</span></div><div class="line"></div><div class="line"><span class="comment">//下标</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstRoomName = john.residence?[<span class="number">0</span>].name &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"The first room name is \(firstRoomName)."</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Unable to retrieve the first room name."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "Unable to retrieve the first room name."。</span></div><div class="line"></div><div class="line"><span class="comment">//多层链接</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> johnsStreet = john.residence?.address?.street &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"John's street name is \(johnsStreet)."</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Unable to retrieve the address."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "Unable to retrieve the address.”。</span></div></pre></td></tr></table></figure></p>
<p>创建了<code>Person</code>的实例<code>john</code>，<code>john</code>中包含类<code>Residence</code>的实例<code>resindence</code>。<br><code>resindence</code>包含了可选类型的属性和方法，值可能为<code>nil</code>，所以访问它的属性，方法和下标时都应该加上<code>?</code>。<br>可选链中只要有一个节点为可选类型，可选链的结果就一定为可选类型。<br>第39行，<code>john.residence?.numberOfRooms</code>的结果类型为<code>Int?</code>。<br>第47行，<code>john.residence?.printNumberOfRooms()</code>的结果类型为<code>void?</code>。这里不能直接用函数结构作为布尔型去判断，而是与<code>nil</code>比较。<br>第55行，<code>john.residence?.getId()</code>的结果类型为<code>String?</code>。<br>第63行，<code>john.residence?[0].name</code>的结果类型为<code>String?</code>。这里的<code>?</code>放在<code>[0]</code>前，因为确保数组有值，才能通过下标去访问。<br>第71行，<code>john.reidence?.address?.street</code>的结果类型为<code>String?</code>。多层的可选链接链接到一起，<code>residence</code>和<code>address</code>都是可选类型，所以使用了两个<code>?</code>。如果给<code>john.residence.address</code>中的<code>address</code>分配实例，应该写作<code>john.residence!.address</code>，强制解析确保<code>residence</code>有值，才能对其中的<code>address</code>分配实例。</p>
<h1 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h1><p>自动引用计数（<em>ARC</em>）跟踪和管理内存，会自动释放不再使用的实例占用的内存。<br>ARC会跟踪和计算每一个实例被多少属性，常量和变量引用，这样的引用称为对实例的强引用。不存在强引用，实例会被销毁，否则实例会被保留。</p>
<h2 id="类实例的循环强引用"><a href="#类实例的循环强引用" class="headerlink" title="类实例的循环强引用"></a>类实例的循环强引用</h2><p>两个类中相互引用，相互保持对方的强引用，这样无法销毁，形成了循环强引用。</p>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</div><div class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</div><div class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">println</span>(<span class="string">"\(name) is being deinitialized"</span>) &#125;dd</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apartment</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> number: <span class="type">Int</span></div><div class="line">    <span class="keyword">init</span>(number: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.number = number &#125;</div><div class="line">    <span class="keyword">var</span> tenant: <span class="type">Person</span>?</div><div class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">println</span>(<span class="string">"Apartment #\(number) is being deinitialized"</span>) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</div><div class="line"><span class="keyword">var</span> number73: <span class="type">Apartment</span>?</div><div class="line"></div><div class="line">john = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</div><div class="line">number73 = <span class="type">Apartment</span>(number: <span class="number">73</span>)</div><div class="line"></div><div class="line">john!.apartment = number73</div><div class="line">number73!.tenant = john</div><div class="line"></div><div class="line">john = <span class="literal">nil</span></div><div class="line">number73 = <span class="literal">nil</span></div></pre></td></tr></table></figure>
<p>上面的代码展示了类实例的循环强引用。<br>类<code>Person</code>中有属性是<code>Apartment</code>类型，类<code>Apartment</code>中有属性是<code>Person</code>类型。<br>声明了实例<code>john</code>和实例<code>number73</code>，并赋值。<br>最后两行把两个实例都设为<code>nil</code>，但是析构函数并没有被调用，因为两个实例还有循环强引用联系，并没有自动销魂，而且造成了内存泄露。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>为了解决循环强引用问题，有两种办法：弱引用（<em>weak reference</em>）和无主引用（<em>unowned reference</em>）。<br>一个实例对另一个实例弱引用或者无主引用，不产生强引用，反过来，另一个实例对一个实例强引用，这样能够相互引用而不产生循环强引用。如果实例的值可能为<code>nil</code>使用弱引用；如果实例的值不可能为<code>nil</code>使用无主引用。</p>
<p>声明时在属性或常量变量前加上<code>weak</code>关键字表示弱引用。<br>两个实例的值都可能为<code>nil</code>，使用弱引用。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">lass <span class="type">Person</span> &#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</div><div class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</div><div class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">println</span>(<span class="string">"\(name) is being deinitialized"</span>) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apartment</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> number: <span class="type">Int</span></div><div class="line">    <span class="keyword">init</span>(number: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.number = number &#125;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> tenant: <span class="type">Person</span>?</div><div class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">println</span>(<span class="string">"Apartment #\(number) is being deinitialized"</span>) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</div><div class="line"><span class="keyword">var</span> number73: <span class="type">Apartment</span>?</div><div class="line"></div><div class="line">john = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</div><div class="line">number73 = <span class="type">Apartment</span>(number: <span class="number">73</span>)</div><div class="line"></div><div class="line">john!.apartment = number73</div><div class="line">number73!.tenant = john</div><div class="line"></div><div class="line">john = <span class="literal">nil</span></div><div class="line"><span class="comment">// prints "John Appleseed is being deinitialized"</span></div><div class="line">number73 = <span class="literal">nil</span></div><div class="line"><span class="comment">// prints "Apartment #73 is being deinitialized"</span></div></pre></td></tr></table></figure></p>
<p>上面的代码和循环强引用代码基本一致，只是在类<code>Apartment</code>的类型为<code>Person?</code>的属性<code>tenant</code>前加上了<code>weak。因为</code>Person?<code>是可选类型，</code>tenant<code>值可能为</code>nil<code>，所以使用弱引用。
最后一句，赋值</code>nil<code>给</code>john<code>后，因为</code>number73<code>对</code>john<code>不是强引用，</code>john<code>这时没有强引用，可以销毁，调用了析构函数。</code>john<code>销毁后，</code>number73<code>没有强引用，也可以被销毁。
如果把</code>number73 = nil<code>和</code>john = nil<code>语句顺序交换，打印顺序不会变，因为没有强引用的</code>john`一定是先销毁。</p>
<h3 id="无主引用"><a href="#无主引用" class="headerlink" title="无主引用"></a>无主引用</h3><p>声明时在属性或常量变量前加上<code>unowned</code>关键字表示无主引用。</p>
<ul>
<li>一个实例的值可能为<code>nil</code>，另一个实例的值不可能为<code>nil</code>。<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> card: <span class="type">CreditCard</span>?</div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">println</span>(<span class="string">"\(name) is being deinitialized"</span>) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> number: <span class="type">Int</span></div><div class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> customer: <span class="type">Customer</span></div><div class="line">    <span class="keyword">init</span>(number: <span class="type">Int</span>, customer: <span class="type">Customer</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.number = number</div><div class="line">        <span class="keyword">self</span>.customer = customer</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">println</span>(<span class="string">"Card #\(number) is being deinitialized"</span>) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> john: <span class="type">Customer</span>?</div><div class="line"></div><div class="line">john = <span class="type">Customer</span>(name: <span class="string">"John Appleseed"</span>)</div><div class="line">john!.card = <span class="type">CreditCard</span>(number: <span class="number">1234_5678_9012_3456</span>, customer: john!)</div><div class="line"></div><div class="line">john = <span class="literal">nil</span></div><div class="line"><span class="comment">// prints "John Appleseed is being deinitialized"</span></div><div class="line"><span class="comment">// prints "Card #1234567890123456 is being deinitialized"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>类<code>CreditCard</code>的类型为<code>Customer</code>的属性<code>customer</code>前加上了<code>unowned</code>。因为<code>customer</code>在构造函数中就会赋予初始值，值不会为<code>nil</code>，所以使用无主引用。<br>最后一句，赋值<code>nil</code>给<code>john</code>后，因为类<code>CreditCard</code>的实例对<code>john</code>不是强引用，<code>john</code>这时没有强引用，可以销毁，调用了析构函数。<code>john</code>销毁后，类<code>Creditcard</code>的实例也没有强引用了，跟着被销毁了。</p>
<ul>
<li>两个实例的值都不可能为<code>nil</code>。<br>这种场景一个类使用无主属性，另一个类使用隐式解析可选类型。<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">let</span> capitalCity: <span class="type">City</span>!</div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, capitalName: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">        <span class="keyword">self</span>.capitalCity = <span class="type">City</span>(name: capitalName, country: <span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> country: <span class="type">Country</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, country: <span class="type">Country</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">        <span class="keyword">self</span>.country = country</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> country = <span class="type">Country</span>(name: <span class="string">"Canada"</span>, capitalName: <span class="string">"Ottawa"</span>)</div><div class="line"><span class="built_in">println</span>(<span class="string">"\(country.name)'s capital city is called \(country.capitalCity.name)"</span>)</div><div class="line"><span class="comment">// prints "Canada's capital city is called Ottawa"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>类<code>City</code>的类型为<code>Country</code>的属性<code>country</code>前加上了<code>unowned</code>表示无主属性。<br>类<code>Country</code>的类型为<code>City!</code>的属性<code>capitalCity</code>在类型后加上了<code>!</code>表示隐式解析可选类型。<br>类<code>Country</code>的实例的<code>country</code>创建时，调用构造器，为<code>name</code>和<code>capiptalCity</code>赋值。因为<code>self</code>属性必须在构造的第二阶段使用，也就是类中所有存储型属性全部有初始值之后才能使用。如果<code>Country</code>的值可以为<code>nil</code>，先给<code>capitalCity</code>赋值<code>nil</code>就可以调用构造器为<code>capitalCity</code>赋予新值。但是这里不可以赋值<code>nil</code>，所以加上了<code>!</code>隐私解析可选类型，默认初始值为<code>nil</code>，可以调用构造器赋予新值。<br>属性<code>capitalCity</code>在调用时可以直接使用，不再需要加<code>!</code>访问。</p>
<h2 id="闭包的循环强引用"><a href="#闭包的循环强引用" class="headerlink" title="闭包的循环强引用"></a>闭包的循环强引用</h2><p>除了两个类实例的循环强引用，类实例和闭包也可能引起循环强引用，比如把闭包赋值给类的一个属性，而闭包中又通过<code>self</code>访问类的一个属性，这就引起了循环强引用，实例不会被销毁。</p>
<h3 id="闭包占用列表"><a href="#闭包占用列表" class="headerlink" title="闭包占用列表"></a>闭包占用列表</h3><p>闭包占用列表（<em>closuer capture list</em>）可以解决闭包引起的循环强引用问题。</p>
<blockquote>
<p>闭包调用类属性，必须加上<code>self.</code>，不能直接通过属性名调用。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> someClosure: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = &#123;</div><div class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>] (index: <span class="type">Int</span>, stringToProcess: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></div><div class="line">    <span class="comment">// closure body goes here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>定义占用列表，使用<code>weak</code>或<code>unowned</code>，视值是否能为<code>nil</code>而定。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">let</span> text: <span class="type">String</span>?</div><div class="line"></div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> asHTML: () -&gt; <span class="type">String</span> = &#123;</div><div class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text = <span class="keyword">self</span>.text &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"&lt;\(self.name) /&gt;"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, text: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">        <span class="keyword">self</span>.text = text</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">deinit</span> &#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"\(name) is being deinitialized"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? = <span class="type">HTMLElement</span>(name: <span class="string">"p"</span>, text: <span class="string">"hello, world"</span>)</div><div class="line"><span class="built_in">println</span>(paragraph!.asHTML())</div><div class="line"><span class="comment">// prints "&lt;p&gt;hello, world&lt;/p&gt;"</span></div><div class="line"></div><div class="line">paragraph = <span class="literal">nil</span></div><div class="line"><span class="comment">// prints "p is being deinitialized"</span></div></pre></td></tr></table></figure></p>
<p>上面的例子中，闭包的指定参数列表和返回类型可以通过上下文推断，所以省略。<code>in</code>放在占用列表之后。<br>这里使用了无主引用，闭包通过<code>unowned self</code>对类<code>HTMLELement</code>无主引用。<br>最后一句，赋值<code>nil</code>给<code>paragraph</code>，没有了闭包对它的强引用，可以销毁并调用析构函数。</p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍Swift的基础知识：通过可选链（&lt;em&gt;optional chaining&lt;/em&gt;）调用属性，方法和下标；自动引用计数（&lt;em&gt;automatic reference counting&lt;/em&gt;）的工作机制；循环强引用的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="http://aidaiz.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://aidaiz.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础入门(8)：继承，构造，析构和嵌套类型</title>
    <link href="http://aidaiz.com/swift_8/"/>
    <id>http://aidaiz.com/swift_8/</id>
    <published>2015-07-21T09:17:02.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍Swift的基础知识：类的继承；枚举，结构体和类的构造过程，析构过程和嵌套类型。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/swift_8" target="_blank" rel="external">Swift基础入门(8)：继承，构造，析构和嵌套类型</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#97;&#105;&#100;&#97;&#105;&#122;&#x79;&#x79;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;">&#97;&#105;&#100;&#97;&#105;&#122;&#x79;&#x79;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-07-24</a></strong></p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>子类（<em>subclass</em>）继承（<em>inherit</em>）继承超类/父类（<em>superclass</em>）的属性，方法，下标和其他特性。<br>声明子类时，将超类名写在子类名的后面，用冒号分割：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> currentSpeed = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"traveling at \(currentSpeed) miles per hour"</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// 什么也不做-因为车辆不一定会有噪音</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span>: <span class="title">Vehicle</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> hasBasket = <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tandem</span>: <span class="title">Bicycle</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> currentNumberOfPassengers = <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> tandem = <span class="type">Tandem</span>()</div><div class="line">tandem.hasBasket = <span class="literal">true</span></div><div class="line">tandem.currentNumberOfPassengers = <span class="number">2</span></div><div class="line">tandem.currentSpeed = <span class="number">22.0</span></div><div class="line"><span class="built_in">println</span>(<span class="string">"Tandem: \(tandem.description)"</span>)</div><div class="line"><span class="comment">// Tandem: traveling at 22.0 miles per hour</span></div></pre></td></tr></table></figure></p>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>重写（<em>overriding</em>）指子类把父类的实例方法，类方法，实例属性和下表脚本等提供自己定制的实现。<br>在重写定义的前面加上关键字<code>override</code>。<br>使用<code>super</code>前缀可以访问超类的属性，方法和下表脚本。</p>
<h3 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Train</span>: <span class="title">Vehicle</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"Choo Choo"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>: <span class="title">Vehicle</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> gear = <span class="number">1</span></div><div class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.description + <span class="string">" in gear \(gear)"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> train = <span class="type">Train</span>()</div><div class="line">train.makeNoise()</div><div class="line"><span class="comment">// prints "Choo Choo"</span></div></pre></td></tr></table></figure>
<h3 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h3><ul>
<li>超类的只读属性在子类中可以重写为读写属性，但是读写属性不能重写为只读属性。</li>
<li>超类的重写属性在子类中必须完整实现setter和getter，可以用<code>super.someProperty</code>返回超类的getter。<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>: <span class="title">Vehicle</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> gear = <span class="number">1</span></div><div class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.description + <span class="string">" in gear \(gear)"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> car = <span class="type">Car</span>()</div><div class="line">car.currentSpeed = <span class="number">25.0</span></div><div class="line">car.gear = <span class="number">3</span></div><div class="line"><span class="built_in">println</span>(<span class="string">"Car: \(car.description)"</span>)</div><div class="line"><span class="comment">// Car: traveling at 25.0 miles per hour in gear 3</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="重写属性观察器"><a href="#重写属性观察器" class="headerlink" title="重写属性观察器"></a>重写属性观察器</h3><p>setter和属性观察器不能同时存在，setter中可以观察到值的变化。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticCar</span>: <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">var</span> currentSpeed: <span class="type">Double</span> &#123;</div><div class="line">        <span class="keyword">didSet</span> &#123;</div><div class="line">            gear = <span class="type">Int</span>(currentSpeed / <span class="number">10.0</span>) + <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> automatic = <span class="type">AutomaticCar</span>()</div><div class="line">automatic.currentSpeed = <span class="number">35.0</span></div><div class="line"><span class="built_in">println</span>(<span class="string">"AutomaticCar: \(automatic.description)"</span>)</div><div class="line"><span class="comment">// AutomaticCar: traveling at 35.0 miles per hour in gear 4</span></div></pre></td></tr></table></figure></p>
<h2 id="防止重写"><a href="#防止重写" class="headerlink" title="防止重写"></a>防止重写</h2><p>属性，方法和下标前面加上<code>final</code>关键字可以防止它们被重写。<br><code>final var</code>，<code>final func</code>，<code>final class func</code>，<code>final subscript</code>。</p>
<h1 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h1><p>构造过程（<em>Inititalization</em>）为实例的每个属性设置初始值和为其执行必要的准备和初始化任务。</p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><h3 id="属性默认值"><a href="#属性默认值" class="headerlink" title="属性默认值"></a>属性默认值</h3><p>属性声明时，可以为其设置默认值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fahrenheit</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> temperature = <span class="number">32.0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f = <span class="type">Fahrenheit</span>()</div><div class="line"><span class="built_in">println</span>(<span class="string">"The default temperature is \(f.temperature)° Fahrenheit"</span>)</div><div class="line"><span class="comment">// 输出 "The default temperature is 32.0° Fahrenheit”</span></div></pre></td></tr></table></figure></p>
<p>构造器，也可以为属性赋初始值，关键字<code>init</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fahrenheit</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> temperature: <span class="type">Double</span></div><div class="line">    <span class="keyword">init</span>() &#123;</div><div class="line">        temperature = <span class="number">32.0</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f = <span class="type">Fahrenheit</span>()</div><div class="line"><span class="built_in">println</span>(<span class="string">"The default temperature is \(f.temperature)° Fahrenheit"</span>)</div><div class="line"><span class="comment">// 输出 "The default temperature is 32.0° Fahrenheit”</span></div></pre></td></tr></table></figure></p>
<h3 id="构造器参数"><a href="#构造器参数" class="headerlink" title="构造器参数"></a>构造器参数</h3><p>构造器可以传入参数。<br>传入参数默认具有和内部参数名一致的外部参数名，相当于默认在参数名前加上了<code>#</code>。<br>用<code>_</code>替代外部参数名，可以取消默认的外部参数名。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> red, green, blue: <span class="type">Double</span></div><div class="line">    <span class="keyword">init</span>(red: <span class="type">Double</span>, g green: <span class="type">Double</span>, <span class="number">_</span> blue: <span class="type">Double</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.red   = red</div><div class="line">        <span class="keyword">self</span>.green = green</div><div class="line">        <span class="keyword">self</span>.blue  = blue</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">init</span>(white: <span class="type">Double</span>) &#123;</div><div class="line">        red   = white</div><div class="line">        green = white</div><div class="line">        blue  = white</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> magenta = <span class="type">Color</span>(red: <span class="number">1.0</span>, g: <span class="number">0.0</span>, <span class="number">1.0</span>)</div><div class="line"><span class="keyword">let</span> halfGray = <span class="type">Color</span>(white: <span class="number">0.5</span>)</div></pre></td></tr></table></figure></p>
<h3 id="可选类型属性"><a href="#可选类型属性" class="headerlink" title="可选类型属性"></a>可选类型属性</h3><p>如果属性为可选类型，构造器自动初始化为<code>nil</code>。</p>
<h3 id="常量属性"><a href="#常量属性" class="headerlink" title="常量属性"></a>常量属性</h3><p>构造器中可以修改常量<code>let</code>属性的值，在构造过程中结束后，常量的值不能被修改。</p>
<h3 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h3><p>所有属性已提供默认值且没有定义构造器的结构体或基类，具有一个默认的构造器，把默认值赋值给属性作为初始值。</p>
<p>前面讲过，结构体的逐一成员构造器，算是一个默认的构造器。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> twoByTwo = <span class="type">Size</span>(width: <span class="number">2.0</span>, height: <span class="number">2.0</span>)</div></pre></td></tr></table></figure></p>
<p>这里<code>Size</code>获得了一个逐一成员构造器<code>init(width: height: )</code>。</p>
<h2 id="值类型的构造器代理"><a href="#值类型的构造器代理" class="headerlink" title="值类型的构造器代理"></a>值类型的构造器代理</h2><p>构造器可以通过调用其他构造器来完成构造过程，称为构造器代理。<br>值类型比较简单，只能调用本身提供的其他构造器，而类可以继承构造器。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</div><div class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</div><div class="line">    <span class="keyword">init</span>() &#123;&#125;</div><div class="line">    <span class="keyword">init</span>(origin: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.origin = origin</div><div class="line">        <span class="keyword">self</span>.size = size</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">init</span>(center: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</div><div class="line">        <span class="keyword">let</span> originX = center.x - (size.width / <span class="number">2</span>)</div><div class="line">        <span class="keyword">let</span> originY = center.y - (size.height / <span class="number">2</span>)</div><div class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结构体<code>Rect</code>中实现了三个构造器。<br>第一个构造器功能和默认构造器类似，把默认值赋值给属性。<br>第二个构造器功能和逐一成员构造器类似，逐一把值赋值给属性。<br>第三个构造器调用了第二个构造器，完成了部分构造过程。</p>
<h2 id="类的构造器代理"><a href="#类的构造器代理" class="headerlink" title="类的构造器代理"></a>类的构造器代理</h2><h3 id="指定构造器和便利构造器"><a href="#指定构造器和便利构造器" class="headerlink" title="指定构造器和便利构造器"></a>指定构造器和便利构造器</h3><p>类类型的构造器要确保所有存储型属性获得初始值，包括继承来的属性，分为指定构造器和便利构造器。</p>
<ul>
<li><p>指定构造器<br>主要的类构造器，根据父类链依次往上调用父类的构造器，每个类都必须拥有至少一个指定构造器。<br>写法和值类型的构造器一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">init</span>(parameters) &#123;</div><div class="line">    statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>便利构造器<br>次要的类构造器，调用同一个类中的指定构造器，也可以创建一个特殊用途或特定输入的实例，只在必要时提供便利构造器。<br>写法和值类型的构造器也基本一样，在<code>init</code>前加上<code>convenience</code>关键字：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(parameters) &#123;</div><div class="line">    statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>指定构造器必须调用其直接父类的指定构造器。</li>
<li>便利构造器必须调用同一类中定义的其他构器。</li>
<li>便利构造器必须最终以调用一个指定构造器结束。</li>
</ul>
<p>也就是说：</p>
<ul>
<li>指定构造器必须总是向上代理</li>
<li>便利构造器必须总是横向代理</li>
</ul>
<h3 id="构造器继承和重写"><a href="#构造器继承和重写" class="headerlink" title="构造器继承和重写"></a>构造器继承和重写</h3><p>重写（<em>Override</em>）指定构造器，在子类中重写实现并调用父类构造器。<br>重写便利构造器，必须通过调用同一类提供的其他指定构造器来实现。</p>
<p>子类不会默认继承父类的构造器。<br>如果特定条件满足，父类构造器也会被自动继承：</p>
<ul>
<li>子类的任意新属性都有默认值，且没有定义任何指定构造器，它将自动继承所有父类的指定构造器。</li>
<li>子类提供了所有父类指定构造器的实现，它将自动继承所有父类的便利构造器。</li>
</ul>
<h3 id="构造过程-1"><a href="#构造过程-1" class="headerlink" title="构造过程"></a>构造过程</h3><p>构造过程分为两个阶段。<br>第一个阶段：<br>沿着构造器链先初始化子类的属性，再代理给父类构造器，初始化父类的属性。<br>当到达构造器链最顶部时，所有的存储型属性都已经赋值。<br>这个阶段不能调用任何实例方法，不能读取任何实例属性的值，不能引用<code>self</code>的值。</p>
<p>第二个阶段：<br>沿着构造器链沿相反方向，从顶部向下，进一步定制实例，可以为任意属性赋新值。<br>这个阶段可以调用实例方法，修改实例属性，并访问<code>self</code>。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: <span class="string">"[Unnamed]"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> namedMeat = <span class="type">Food</span>(name: <span class="string">"Bacon"</span>)</div><div class="line"><span class="comment">// namedMeat 的名字是 "Bacon”</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> mysteryMeat = <span class="type">Food</span>()</div><div class="line"><span class="comment">// mysteryMeat 的名字是 [Unnamed]</span></div></pre></td></tr></table></figure>
<p>类<code>Food</code>提供了一个指定构造器<code>init(name: String)</code>和一个便利构造器<code>init()</code>。<br>第11行：指定构造器，初始化属性<code>name</code>，因为<code>Food</code>没有父类，所以结束构造过程。<br>第14行：便利构造器，调用了同一个类的指定构造器并给参数<code>name</code>传入值<code>[Unnamed]</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipeIngredient</span>: <span class="title">Food</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, quantity: <span class="type">Int</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.quantity = quantity</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, quantity: <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> sixEggs = <span class="type">RecipeIngredient</span>(name: <span class="string">"Eggs"</span>, quantity: <span class="number">6</span>)</div><div class="line"><span class="keyword">let</span> oneBacon = <span class="type">RecipeIngredient</span>(name: <span class="string">"Bacon"</span>)</div><div class="line"><span class="keyword">let</span> oneMysteryItem = <span class="type">RecipeIngredient</span>()</div></pre></td></tr></table></figure></p>
<p>类<code>RecipeIngredient</code>继承类<code>Food</code>，提供了一个指定构造器<code>init(name: String, quantity: Int)</code>和一个便利构造器<code>init(name: String)。
第12行：指定构造器，先初始化子类的属性</code>quantity<code>，再代理给父类</code>Food<code>的</code>init(name: String)<code>。
第13行：便利构造器，调用了同一个类的指定构造器并给参数</code>name<code>和</code>quantity<code>传入了值。
因为</code>init(name: String)<code>和父类的</code>init(name: String)<code>使用了相同的参数，所以在前面使用</code>override<code>标识。
第14行：父类的</code>init()<code>被子类继承了，但是它其中调用的</code>init(name: String)<code>替换成子类</code>RecipeIngredient`重写过后的便利构造器。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span>: <span class="title">RecipeIngredient</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> purchased = <span class="literal">false</span></div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">var</span> output = <span class="string">"\(quantity) x \(name.lowercaseString)"</span></div><div class="line">        output += purchased ? <span class="string">" ✔"</span> : <span class="string">" ✘"</span></div><div class="line">        <span class="keyword">return</span> output</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> breakfastList = [</div><div class="line">    <span class="type">ShoppingListItem</span>(),</div><div class="line">    <span class="type">ShoppingListItem</span>(name: <span class="string">"Bacon"</span>),</div><div class="line">    <span class="type">ShoppingListItem</span>(name: <span class="string">"Eggs"</span>, quantity: <span class="number">6</span>),</div><div class="line">]</div><div class="line">breakfastList[<span class="number">0</span>].name = <span class="string">"Orange juice"</span></div><div class="line">breakfastList[<span class="number">0</span>].purchased = <span class="literal">true</span></div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> breakfastList &#123;</div><div class="line">    <span class="built_in">println</span>(item.description)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1 x orange juice ✔</span></div><div class="line"><span class="comment">// 1 x bacon ✘</span></div><div class="line"><span class="comment">// 6 x eggs ✘</span></div></pre></td></tr></table></figure></p>
<p>类<code>ShoppingListItem</code>继承类<code>RecipeIngredient</code>。<br>因为子类的新属性<code>purchased</code>有默认值，而且自己没有定义任何构造器，所以继承了父类的所有指定构造器。<br>这时就满足上面提到继承父类构造器的第二个条件：子类提供了所有父类指定构造器的实现。<br>所以子类也继承了父类的所有便利构造器。<br>类<code>shoppingListItem</code>就继承了<code>init()</code>，<code>init(name: String)</code>和<code>init(name: String, quantity: Int)</code>三种构造器。</p>
<h2 id="可失败构造器"><a href="#可失败构造器" class="headerlink" title="可失败构造器"></a>可失败构造器</h2><p>构造过程中可能因为传入无效参数值，缺少资源，不满足必要条件等原因构造失败的构造器，称为可失败构造器。</p>
<h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><p>可失败构造器在<code>init</code>关键字后面加上<code>?</code>，即<code>init?</code>。<br>并在失败的情况下加上<code>return nil</code>使构造器返回<code>nil</code>，非可失败构造器中不能使用<code>return</code>返回值。<br>可失败构造器的参数名和参数类型不能与其他非可失败构造器完全相同。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> species: <span class="type">String</span></div><div class="line">    <span class="keyword">init</span>?(species: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">if</span> species.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line">        <span class="keyword">self</span>.species = species</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> someCreature = <span class="type">Animal</span>(species: <span class="string">"Giraffe"</span>)</div><div class="line"><span class="comment">// someCreature 的类型是 Animal? 而不是 Animal</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> giraffe = someCreature &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"An animal was initialized with a species of \(giraffe.species)"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "An animal was initialized with a species of Giraffe"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> anonymousCreature = <span class="type">Animal</span>(species: <span class="string">""</span>)</div><div class="line"><span class="comment">// anonymousCreature 的类型是 Animal?, 而不是 Animal</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> anonymousCreature == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"The anonymous creature could not be initialized"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "The anonymous creature could not be initialized"</span></div></pre></td></tr></table></figure></p>
<h3 id="枚举类型的可失败构造器"><a href="#枚举类型的可失败构造器" class="headerlink" title="枚举类型的可失败构造器"></a>枚举类型的可失败构造器</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureUnit</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Kelvin</span>, <span class="type">Celsius</span>, <span class="type">Fahrenheit</span></div><div class="line">    <span class="keyword">init</span>?(symbol: <span class="type">Character</span>) &#123;</div><div class="line">        <span class="keyword">switch</span> symbol &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"K"</span>:</div><div class="line">            <span class="keyword">self</span> = .<span class="type">Kelvin</span></div><div class="line">        <span class="keyword">case</span> <span class="string">"C"</span>:</div><div class="line">            <span class="keyword">self</span> = .<span class="type">Celsius</span></div><div class="line">        <span class="keyword">case</span> <span class="string">"F"</span>:</div><div class="line">            <span class="keyword">self</span> = .<span class="type">Fahrenheit</span></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> fahrenheitUnit = <span class="type">TemperatureUnit</span>(symbol: <span class="string">"F"</span>)</div><div class="line"><span class="keyword">if</span> fahrenheitUnit != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"This is a defined temperature unit, so initialization succeeded."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "This is a defined temperature unit, so initialization succeeded."</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> unknownUnit = <span class="type">TemperatureUnit</span>(symbol: <span class="string">"X"</span>)</div><div class="line"><span class="keyword">if</span> unknownUnit == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"This is not a defined temperature unit, so initialization failed."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "This is not a defined temperature unit, so initialization failed."</span></div></pre></td></tr></table></figure>
<p>当参数值不能与任意一枚举成员相匹配时，该枚举类型的构建过程失败。</p>
<p>带原始值的枚举类型会自带一个可失败构造器<code>init?(rawValue: )</code>，<code>rawValue</code>是一个默认参数，和枚举类型的原始值类型一致。<br>如果该参数的值能和枚举类型成员所带的原始值匹配，则构建器构造一个带此原始值的枚举成员，否则构造失败。<br>上面的例子可以重写为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureUnit</span>: <span class="title">Character</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Kelvin</span> = <span class="string">"K"</span>, <span class="type">Celsius</span> = <span class="string">"C"</span>, <span class="type">Fahrenheit</span> = <span class="string">"F"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> fahrenheitUnit = <span class="type">TemperatureUnit</span>(rawValue: <span class="string">"F"</span>)</div><div class="line"><span class="keyword">if</span> fahrenheitUnit != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"This is a defined temperature unit, so initialization succeeded."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// prints "This is a defined temperature unit, so initialization succeeded."</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> unknownUnit = <span class="type">TemperatureUnit</span>(rawValue: <span class="string">"X"</span>)</div><div class="line"><span class="keyword">if</span> unknownUnit == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"This is not a defined temperature unit, so initialization failed."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// prints "This is not a defined temperature unit, so initialization failed."</span></div></pre></td></tr></table></figure></p>
<h3 id="类的可失败构造器"><a href="#类的可失败构造器" class="headerlink" title="类的可失败构造器"></a>类的可失败构造器</h3><p>类的可失败构造器只能在所有类属性被初始化和所有类之间的构造代理之间的代理调用发生完后触发失败行为。<br>而值类型的可失败构造器可以随时随地触发。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span>!</div><div class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> bowTie = <span class="type">Product</span>(name: <span class="string">"bow tie"</span>) &#123;</div><div class="line">    <span class="comment">// 不需要检查 bowTie.name == nil</span></div><div class="line">    <span class="built_in">println</span>(<span class="string">"The product's name is \(bowTie.name)"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "The product's name is bow tie"</span></div></pre></td></tr></table></figure></p>
<p>类<code>Product</code>的可失败构造器必须建立在<code>name</code>被赋值的情况下。<br>所以<code>name</code>被声明为隐式解析可选类型（<code>String!</code>）保证触发失败条件时，<code>name</code>一定有值。<br>类<code>Prodcut</code>构建成功时，<code>name</code>一定有一个非<code>nil</code>值，可以直接访问<code>name</code>。</p>
<h3 id="可失败构造器的代理"><a href="#可失败构造器的代理" class="headerlink" title="可失败构造器的代理"></a>可失败构造器的代理</h3><p>可失败构造器的代理规则和构造器基本一致，只是一旦触发构造失败，整个构造过程就会被立即终止。<br>可失败构造器可以在同一类中代理调用其他非可失败构造器，这样可以为已有的构造器添加构造失败的条件。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span>!</div><div class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItem</span>: <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> quantity: <span class="type">Int</span>!</div><div class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>, quantity: <span class="type">Int</span>) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</div><div class="line">        <span class="keyword">if</span> quantity &lt; <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line">        <span class="keyword">self</span>.quantity = quantity</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> twoSocks = <span class="type">CartItem</span>(name: <span class="string">"sock"</span>, quantity: <span class="number">2</span>) &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Item: \(twoSocks.name), quantity: \(twoSocks.quantity)"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "Item: sock, quantity: 2"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> zeroShirts = <span class="type">CartItem</span>(name: <span class="string">"shirt"</span>, quantity: <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Unable to initialize zero shirts"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "Unable to initialize zero shirts"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> oneUnnamed = <span class="type">CartItem</span>(name: <span class="string">""</span>, quantity: <span class="number">1</span>) &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Unable to initialize one unnamed product"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印 "Unable to initialize one unnamed product"</span></div></pre></td></tr></table></figure></p>
<p>第18行：构造成功。<br>第23行：<code>quantiry</code>的值小于<code>1</code>，不满足条件，构造失败。<br>第30行：<code>name</code>为空，父类<code>Product</code>可失败构造器触发构造失败，整个构造过程停止并失败。</p>
<h3 id="可失败构造器的重写"><a href="#可失败构造器的重写" class="headerlink" title="可失败构造器的重写"></a>可失败构造器的重写</h3><p>父类的可失败构造器可以被子类的可失败构造器或者非可失败构造器重写。<br>但是父类的非可失败构造器不可以被子类的可失败构造器重写。<br>如果用非可失败构造器重写可失败构造器时，不再向上代理父类的可失败构造器，非可失败构造器不不会代理调用可失败构造器。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">    <span class="comment">// 该构造器构建了一个name属性值为nil的document对象</span></div><div class="line">    <span class="keyword">init</span>() &#123;&#125;</div><div class="line">    <span class="comment">// 该构造器构建了一个name属性值为非空字符串的document对象</span></div><div class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticallyNamedDocument</span>: <span class="title">Document</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">        <span class="keyword">self</span>.name = <span class="string">"[Untitled]"</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">        <span class="keyword">if</span> name.isEmpty &#123;</div><div class="line">            <span class="keyword">self</span>.name = <span class="string">"[Untitled]"</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">self</span>.name = name</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="隐私解析可选类型的可失败构造器"><a href="#隐私解析可选类型的可失败构造器" class="headerlink" title="隐私解析可选类型的可失败构造器"></a>隐私解析可选类型的可失败构造器</h3><p><code>init!</code>同<code>init?</code>一样都是可失败构造器，该可失败构造器就会构造一个特定类型的隐私解析可选类型的对象。<br><code>init?</code>和<code>init!</code>可以相互代理调用，相互重写。<br><code>init</code>也可以代理调用<code>init!</code>，但这会触发一个断言：<code>init!</code>是否会触发构造失败。</p>
<h3 id="必要构造器"><a href="#必要构造器" class="headerlink" title="必要构造器"></a>必要构造器</h3><p>在类的构造器前添加<code>required</code>关键字表示该类的子类都必须实现该构造器。<br>子类重写父类的<code>required</code>必要构造器时，也要加上<code>required</code>关键字，也是必要构造器。<br>覆盖基类的必要构造器时，不需要添加<code>override</code>关键字。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="comment">// 在这里添加该必要构造器的实现代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubclass</span>: <span class="title">SomeClass</span> </span>&#123;</div><div class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="comment">// 在这里添加子类必要构造器的实现代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不一定需要显示的实现父类的必要构造器，只要满足父类的必要构造器需求即可。</p>
<h2 id="闭包设置属性默认值"><a href="#闭包设置属性默认值" class="headerlink" title="闭包设置属性默认值"></a>闭包设置属性默认值</h2><p>闭包可以用来为属性提供定制的默认值，返回和属性类型相同类型的默认值。<br>在闭包中不能使用其他属性，不能访问其他实例方法，不能使用<code>self</code>属性。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> someProperty: <span class="type">SomeType</span> = &#123;</div><div class="line">        <span class="comment">// 在这个闭包中给 someProperty 创建一个默认值</span></div><div class="line">        <span class="comment">// someValue 必须和 SomeType 类型相同</span></div><div class="line">        <span class="keyword">return</span> someValue</div><div class="line">        &#125;()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>闭包后面接<code>()</code>表示闭包立刻执行，否则会把闭包赋值给<code>someProperty</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Checkerboard</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> boardColors: [<span class="type">Bool</span>] = &#123;</div><div class="line">        <span class="keyword">var</span> temporaryBoard = [<span class="type">Bool</span>]()</div><div class="line">        <span class="keyword">var</span> isBlack = <span class="literal">false</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</div><div class="line">                temporaryBoard.append(isBlack)</div><div class="line">                isBlack = !isBlack</div><div class="line">            &#125;</div><div class="line">            isBlack = !isBlack</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> temporaryBoard</div><div class="line">        &#125;()</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">squareIsBlackAtRow</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> boardColors[(row * <span class="number">10</span>) + column]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> board = <span class="type">Checkerboard</span>()</div><div class="line"><span class="built_in">println</span>(board.squareIsBlackAtRow(<span class="number">0</span>, column: <span class="number">1</span>))</div><div class="line"><span class="comment">// 输出 "true"</span></div><div class="line"><span class="built_in">println</span>(board.squareIsBlackAtRow(<span class="number">9</span>, column: <span class="number">9</span>))</div><div class="line"><span class="comment">// 输出 "false"</span></div></pre></td></tr></table></figure></p>
<p>这里的闭包把类<code>Checkerboard</code>的布尔型数组<code>boardColors</code>初始化为<code>true</code>和<code>false</code>交替的数组，可以用来标识国际象棋的棋盘。</p>
<h1 id="析构过程"><a href="#析构过程" class="headerlink" title="析构过程"></a>析构过程</h1><p>Swift会自动释放不再需要的实例以释放资源。如果我们需要进行一些额外的清理，就需要使用析构函数。<br>每个类最多只能有一个析构函数。<br>析构函数使用关键字<code>deinit</code>，不带任何参数，在写法上不带括号：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</div><div class="line">    <span class="keyword">deinit</span> &#123; </div><div class="line">	<span class="comment">//some action</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>析构函数是在实例释放前被自动调用，不允许自己主动调用。<br>子类的析构函数先调用，父类的析构函数后调用。子类没有提供析构函数，也会调用父类的析构函数。</p>
<h1 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h1><p>枚举，类和结构体可以想换嵌套，将需要嵌套的类型定义写在被嵌套类型的区域{}内，可以实现多级嵌套。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlackjackCard</span> </span>&#123;</div><div class="line">    <span class="comment">// 嵌套定义枚举型Suit</span></div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Suit</span>: <span class="title">Character</span> </span>&#123;</div><div class="line">       <span class="keyword">case</span> <span class="type">Spades</span> = <span class="string">"♠"</span>, <span class="type">Hearts</span> = <span class="string">"♡"</span>, <span class="type">Diamonds</span> = <span class="string">"♢"</span>, <span class="type">Clubs</span> = <span class="string">"♣"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 嵌套定义枚举型Rank</span></div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Rank</span>: <span class="title">Int</span> </span>&#123;</div><div class="line">       <span class="keyword">case</span> <span class="type">Two</span> = <span class="number">2</span>, <span class="type">Three</span>, <span class="type">Four</span>, <span class="type">Five</span>, <span class="type">Six</span>, <span class="type">Seven</span>, <span class="type">Eight</span>, <span class="type">Nine</span>, <span class="type">Ten</span></div><div class="line">       <span class="keyword">case</span> <span class="type">Jack</span>, <span class="type">Queen</span>, <span class="type">King</span>, <span class="type">Ace</span></div><div class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">Values</span> </span>&#123;</div><div class="line">           <span class="keyword">let</span> first: <span class="type">Int</span>, second: <span class="type">Int</span>?</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">var</span> values: <span class="type">Values</span> &#123;</div><div class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">        <span class="keyword">case</span> .<span class="type">Ace</span>:</div><div class="line">            <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="number">1</span>, second: <span class="number">11</span>)</div><div class="line">        <span class="keyword">case</span> .<span class="type">Jack</span>, .<span class="type">Queen</span>, .<span class="type">King</span>:</div><div class="line">            <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="number">10</span>, second: <span class="literal">nil</span>)</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="keyword">self</span>.toRaw(), second: <span class="literal">nil</span>)</div><div class="line">            &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// BlackjackCard 的属性和方法</span></div><div class="line">    <span class="keyword">let</span> rank: <span class="type">Rank</span>, suit: <span class="type">Suit</span></div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">var</span> output = <span class="string">"suit is \(suit.toRaw()),"</span></div><div class="line">        output += <span class="string">" value is \(rank.values.first)"</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> second = rank.values.second &#123;</div><div class="line">            output += <span class="string">" or \(second)"</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> output</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结构体<code>BlackjackCard</code>用来存储“二十一点游戏”中的扑克牌，嵌套了枚举类型<code>Suit</code>表示花色，嵌套了枚举类型<code>Rank</code>表示点数。而且<code>Rank</code>中又定义了结构体<code>Values</code>准确描述牌的大小：数字牌表示本身数字的大小，<code>Ace</code>表示1或者11，<code>Jack</code>，<code>Queen</code>和<code>King</code>表示10。<br>结构体有默认的成员构造函数，这里的默认构造函数为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> theAceOfSpades = <span class="type">BlackjackCard</span>(rank: .<span class="type">Ace</span>, suit: .<span class="type">Spades</span>)</div><div class="line"><span class="built_in">println</span>(<span class="string">"theAceOfSpades: \(theAceOfSpades.description)"</span>)</div><div class="line"><span class="comment">// 打印出 "theAceOfSpades: suit is ♠, value is 1 or 11"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> heartsSymbol = <span class="type">BlackjackCard</span>.<span class="type">Suit</span>.<span class="type">Hearts</span>.toRaw()</div><div class="line"><span class="comment">// 红心的符号 为 "♡"</span></div></pre></td></tr></table></figure></p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍Swift的基础知识：类的继承；枚举，结构体和类的构造过程，析构过程和嵌套类型。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="http://aidaiz.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://aidaiz.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础入门(7)：属性，方法和下标</title>
    <link href="http://aidaiz.com/swift_7/"/>
    <id>http://aidaiz.com/swift_7/</id>
    <published>2015-07-20T02:10:20.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍Swift的基础知识：枚举，结构体和类的属性，方法和下标。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/swift_7" target="_blank" rel="external">Swift基础入门(7)：属性，方法和下标</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x61;&#105;&#100;&#97;&#x69;&#x7a;&#121;&#121;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;">&#x61;&#105;&#100;&#97;&#x69;&#x7a;&#121;&#121;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-07-27</a></strong></p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>属性分为存储属性（只能用于类和结构体）和计算属性（可用于类，结构体和枚举）。</p>
<h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><p>存储属性可用<code>var</code>或<code>let</code>修饰。<br>结构体用<code>let</code>修饰，属性不可以更改，因为结构体是值类型。<br>类用<code>let</code>修饰，属性可以更改，因为类是引用类型。<br>结构体可以在构造时逐一初始化属性，而类不可以，参见<a href="http://aidaizyy.github.io/swift_6/#类和结构体" target="_blank" rel="external">类和结构体</a>。</p>
<ul>
<li>延迟属性<br>延迟属性用<code>lazy</code>标示，且必须使用<code>var</code>关键字，只有在第一次被调用时才会计算其初始值，在构造时不会计算初始值。<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataImporter</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">    DataImporter 是一个将外部文件中的数据导入的类。</div><div class="line">    这个类的初始化会消耗不少时间。</div><div class="line">    */</div><div class="line">    <span class="keyword">var</span> fileName = <span class="string">"data.txt"</span></div><div class="line">    <span class="comment">// 这是提供数据导入功能</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataManager</span> </span>&#123;</div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> importer = <span class="type">DataImporter</span>()</div><div class="line">    <span class="keyword">var</span> data = [<span class="type">String</span>]()</div><div class="line">    <span class="comment">// 这是提供数据管理功能</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> manager = <span class="type">DataManager</span>()</div><div class="line">manager.data.append(<span class="string">"Some data"</span>)</div><div class="line">manager.data.append(<span class="string">"Some more data"</span>)</div><div class="line"><span class="comment">// DataImporter 实例的 importer 属性还没有被创建</span></div><div class="line"></div><div class="line"><span class="built_in">println</span>(manager.importer.fileName)</div><div class="line"><span class="comment">// DataImporter 实例的 importer 属性现在被创建了</span></div><div class="line"><span class="comment">// 输出 "data.txt”</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>以上并未给出全部代码，类<code>DataManager</code>中声明了延迟属性<code>importer</code>。<br>类<code>DataImporter</code>实现数据导入功能，会消耗不少时间。<br>初始化类<code>DataManager</code>时，延迟属性并不会创建。<br>只有在<code>println(manager.importer.fileName)</code>时，属性<code>importer</code>第一次被调用时，才会创建延迟属性<code>importer</code>，完成数据导入功能。</p>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>计算属性不直接存储值，提供getter获取值和可选的setter来间接设置其他属性的值，必须用<code>var</code>修饰。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</div><div class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</div><div class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</div><div class="line">    <span class="keyword">get</span> &#123;</div><div class="line">        <span class="keyword">let</span> centerX = origin.x + (size.width / <span class="number">2</span>)</div><div class="line">        <span class="keyword">let</span> centerY = origin.y + (size.height / <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">set</span>(newCenter) &#123;</div><div class="line">        origin.x = newCenter.x - (size.width / <span class="number">2</span>)</div><div class="line">        origin.y = newCenter.y - (size.height / <span class="number">2</span>)</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> square = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>),</div><div class="line">    size: <span class="type">Size</span>(width: <span class="number">10.0</span>, height: <span class="number">10.0</span>))</div><div class="line"><span class="keyword">let</span> initialSquareCenter = square.center</div><div class="line">square.center = <span class="type">Point</span>(x: <span class="number">15.0</span>, y: <span class="number">15.0</span>)</div><div class="line"><span class="built_in">println</span>(<span class="string">"square.origin is now at (\(square.origin.x), \(square.origin.y))"</span>)</div><div class="line"><span class="comment">// 输出 "square.origin is now at (10.0, 10.0)”</span></div></pre></td></tr></table></figure></p>
<p>在结构体<code>Rect</code>中，属性<code>center</code>是计算属性，分别设置了<code>get</code>方法和<code>set</code>方法。<br><code>set</code>方法可以不指定新值的参数名称，比如<code>newCenter</code>，在方法中直接使用默认名称<code>newValue</code>，上面可写作：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> &#123;</div><div class="line">        origin.x = newValue.x - (size.width / <span class="number">2</span>)</div><div class="line">        origin.y = newValue.y - (size.height / <span class="number">2</span>)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>只读计算属性<br>不设置setter，只设置getter的计算属性称为只读计算属性。<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cuboid</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span>, depth = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> &#123;</div><div class="line">    <span class="keyword">return</span> width * height * depth</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> fourByFiveByTwo = <span class="type">Cuboid</span>(width: <span class="number">4.0</span>, height: <span class="number">5.0</span>, depth: <span class="number">2.0</span>)</div><div class="line"><span class="built_in">println</span>(<span class="string">"the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)"</span>)</div><div class="line"><span class="comment">// 输出 "the volume of fourByFiveByTwo is 40.0"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>只读计算属性可省略<code>get</code>关键字。</p>
<h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><p>属性观察器可以监控和响应属性值的变化。</p>
<ul>
<li>willSet 在设置新值之前调用</li>
<li>didSet 在设置新值之后调用<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StepCounter</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> totalSteps: <span class="type">Int</span> = <span class="number">0</span> &#123;</div><div class="line">    <span class="keyword">willSet</span>(newTotalSteps) &#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"About to set totalSteps to \(newTotalSteps)"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">didSet</span>(oldTotalSteps) &#123;</div><div class="line">        <span class="keyword">if</span> totalSteps &gt; oldTotalSteps  &#123;</div><div class="line">            <span class="built_in">println</span>(<span class="string">"Added \(totalSteps - oldTotalSteps) steps"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> stepCounter = <span class="type">StepCounter</span>()</div><div class="line">stepCounter.totalSteps = <span class="number">200</span></div><div class="line"><span class="comment">// About to set totalSteps to 200</span></div><div class="line"><span class="comment">// Added 200 steps</span></div><div class="line">stepCounter.totalSteps = <span class="number">360</span></div><div class="line"><span class="comment">// About to set totalSteps to 360</span></div><div class="line"><span class="comment">// Added 160 steps</span></div><div class="line">stepCounter.totalSteps = <span class="number">896</span></div><div class="line"><span class="comment">// About to set totalSteps to 896</span></div><div class="line"><span class="comment">// Added 536 steps</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>willSet</code>如果不指定新值参数名，可用<code>newValue</code>替代。<br><code>didSet</code>如果不指定旧值参数名，可用<code>oldValue</code>替代。<br>通过重写的方式可以为继承来的存储属性和计算属性添加属性观察器。</p>
<p>计算属性和属性观察器也可以用于全局变量和局部变量。<br>全局的常量变量都是延迟计算的，不需要标记<code>lazy</code>。而局部的常量变量不会延迟计算。</p>
<h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><p>类型属性指所有类型实例公用的属性，类似于其他语言中的静态属性（<em>static</em>）。<br>值类型（枚举和结构体）可以定义存储型和计算型的类型属性。<br>引用类型（类）只能定义计算型的类型属性。<br>存储型的类型属性必须指定默认值。</p>
<p>值类型（枚举和结构体）中在类型属性前加上关键字<code>static</code>，而引用类型（类）中在类型属性前加上关键字<code>class</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</div><div class="line">    <span class="comment">// 这里返回一个 Int 值</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</div><div class="line">    <span class="comment">// 这里返回一个 Int 值</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">computedTypeProperty</span>: <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="comment">// 这里返回一个 Int 值</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">println</span>(<span class="type">SomeClass</span>.computedTypeProperty)</div><div class="line"><span class="comment">// 输出 "42"</span></div><div class="line"></div><div class="line"><span class="built_in">println</span>(<span class="type">SomeStructure</span>.storedTypeProperty)</div><div class="line"><span class="comment">// 输出 "Some value."</span></div><div class="line"><span class="type">SomeStructure</span>.storedTypeProperty = <span class="string">"Another value."</span></div><div class="line"><span class="built_in">println</span>(<span class="type">SomeStructure</span>.storedTypeProperty)</div><div class="line"><span class="comment">// 输出 "Another value.”</span></div></pre></td></tr></table></figure></p>
<p>这里计算型类型属性都是只读型，也可以定义为可读可写。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>方法是定义在类，结构体和枚举中的方法，和函数类似。<br>类，结构体和枚举创建实例后，其中的方法被称为实例方法，只属于当前实例。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="built_in">count</span>++</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">incrementBy</span><span class="params">(amount: Int)</span></span> &#123;</div><div class="line">    <span class="built_in">count</span> += amount</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="built_in">count</span> = <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> counter = <span class="type">Counter</span>()</div><div class="line"><span class="comment">// 初始计数值是0</span></div><div class="line">counter.increment()</div><div class="line"><span class="comment">// 计数值现在是1</span></div><div class="line">counter.incrementBy(<span class="number">5</span>)</div><div class="line"><span class="comment">// 计数值现在是6</span></div><div class="line">counter.reset()</div><div class="line"><span class="comment">// 计数值现在是0</span></div></pre></td></tr></table></figure></p>
<h3 id="外部参数名"><a href="#外部参数名" class="headerlink" title="外部参数名"></a>外部参数名</h3><p>方法默认第一个参数没有外部参数名，第二个及以后参数默认有外部参数名，和参数名一致，相当于默认在参数前加上了<code>#</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> = <span class="number">0</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">incrementBy</span><span class="params">(amount: Int, numberOfTimes: Int)</span></span> &#123;</div><div class="line">    <span class="built_in">count</span> += amount * numberOfTimes</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> counter = <span class="type">Counter</span>()</div><div class="line">counter.incrementBy(<span class="number">5</span>, numberOfTimes: <span class="number">3</span>)</div><div class="line"><span class="comment">// counter value is now 15</span></div></pre></td></tr></table></figure></p>
<p>也可以在第一个参数名添加外部参数名，也可以用_放在第二个及以后的参数名前取消默认的外部参数名。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">incrementBy</span><span class="params">(#amount: Int, <span class="number">_</span> numberOfTimes: Int)</span></span> &#123;</div><div class="line">        <span class="built_in">count</span> += amount * numberOfTimes</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> counter = <span class="type">Counter</span>()</div><div class="line">counter.incrementBy(amount: <span class="number">5</span>, <span class="number">3</span>)</div><div class="line"><span class="built_in">println</span>(counter.<span class="built_in">count</span>)</div><div class="line"><span class="comment">// counter value is now 15</span></div></pre></td></tr></table></figure></p>
<p>关于外部参数名，参见<a href="http://aidaizyy.github.io/swift_5/#外部参数名" target="_blank" rel="external">函数的外部参数名</a>。</p>
<h3 id="self属性"><a href="#self属性" class="headerlink" title="self属性"></a>self属性</h3><p>在每个实例中，都有一个隐藏属性<code>self</code>，指代实例变身，以便方法调用实例本身。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">self</span>.<span class="built_in">count</span>++</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h3><p>结构体和枚举是值类型。值类型的属性不可以在实例方法中被修改。<br>变异方法可以完成对属性的修改，在<code>func</code>前加上<code>mutating</code>关键字。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveByX</span><span class="params">(deltaX: Double, y deltaY: Double)</span></span> &#123;</div><div class="line">    x += deltaX</div><div class="line">    y += deltaY</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> somePoint = <span class="type">Point</span>(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</div><div class="line">somePoint.moveByX(<span class="number">2.0</span>, y: <span class="number">3.0</span>)</div><div class="line"><span class="built_in">println</span>(<span class="string">"The point is now at (\(somePoint.x), \(somePoint.y))"</span>)</div><div class="line"><span class="comment">// 输出 "The point is now at (3.0, 4.0)"</span></div></pre></td></tr></table></figure></p>
<p>变异方法也可以给<code>self</code>赋值，即新建一个实例替代旧的实例。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveByX</span><span class="params">(deltaX: Double, y deltaY: Double)</span></span> &#123;</div><div class="line">    <span class="keyword">self</span> = <span class="type">Point</span>(x: x + deltaX, y: y + deltaY)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TriStateSwitch</span> </span>&#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Off</span>, <span class="type">Low</span>, <span class="type">High</span></div><div class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Off</span>:</div><div class="line">      <span class="keyword">self</span> = <span class="type">Low</span></div><div class="line">    <span class="keyword">case</span> <span class="type">Low</span>:</div><div class="line">      <span class="keyword">self</span> = <span class="type">High</span></div><div class="line">    <span class="keyword">case</span> <span class="type">High</span>:</div><div class="line">      <span class="keyword">self</span> = <span class="type">Off</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> ovenLight = <span class="type">TriStateSwitch</span>.<span class="type">Low</span></div><div class="line">ovenLight.next()</div><div class="line"><span class="comment">// ovenLight 现在等于 .High</span></div><div class="line">ovenLight.next()</div><div class="line"><span class="comment">// ovenLight 现在等于 .Off</span></div></pre></td></tr></table></figure>
<p>类是引用类型，实例方法可以直接修改属性。</p>
<h2 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h2><p>类型方法和类型属性类似，都是指所有类型实例公共的方法，类似于其他语言中的静态方法（<em>static</em>）。<br>类型方法在类型前加上<code>class</code>关键字。<br>类型方法能够直接通过静态属性的名称访问静态属性。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">someTypeMethod</span>() </span>&#123;</div><div class="line">    <span class="comment">// type method implementation goes here</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="type">SomeClass</span>.someTypeMethod()</div></pre></td></tr></table></figure></p>
<h1 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h1><p>下标（<em>subscripts</em>）可以定义在类，结构体和枚举中，是访问对象，集合和序列的快捷方式。比如<a href="http://aidaizyy.github.io/swift_3/#访问" target="_blank" rel="external">数组的访问</a>：Array[index]，<a href="http://aidaizyy.github.io/swift_3/#访问-1" target="_blank" rel="external">字典的访问</a>：Dictionary[key]。<br>下标的定义类似于实例方法和计算性属性的混合。<br>使用<code>subscript</code>关键字，定义了传入参数数量和类型和返回类型，定义了getter和setter。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">get</span> &#123;</div><div class="line">      <span class="comment">// 返回与入参匹配的Int类型的值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">set</span>(newValue) &#123;</div><div class="line">      <span class="comment">// 执行赋值操作</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>getter和setter的定义和计算型属性一样。<br>setter中可以使用<code>newValue</code>默认值，可以省略setter定义成只读类型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TimesTable</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> multiplier: <span class="type">Int</span></div><div class="line">    <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</div><div class="line">      <span class="keyword">return</span> multiplier * index</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> threeTimesTable = <span class="type">TimesTable</span>(multiplier: <span class="number">3</span>)</div><div class="line"><span class="built_in">println</span>(<span class="string">"3的6倍是\(threeTimesTable[6])"</span>)</div><div class="line"><span class="comment">// 输出 "3的6倍是18"</span></div></pre></td></tr></table></figure></p>
<p>下标允许任意数量的传入参数，任意类型的传入参数和任意类型的返回值。<br>可以使用<a href="http://aidaizyy.github.io/swift_5/#变量参数" target="_blank" rel="external">变量参数</a>和<a href="http://aidaizyy.github.io/swift_5/#可变参数" target="_blank" rel="external">可变参数</a>，但是不能使用<a href="http://aidaizyy.github.io/swift_5/#输入输出参数" target="_blank" rel="external">输入输出参数（inout）</a>和<a href="http://aidaizyy.github.io/swift_5/#默认参数值" target="_blank" rel="external">默认参数值</a>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> rows: <span class="type">Int</span>, columns: <span class="type">Int</span></div><div class="line">    <span class="keyword">var</span> grid: [<span class="type">Double</span>]</div><div class="line">    <span class="keyword">init</span>(rows: <span class="type">Int</span>, columns: <span class="type">Int</span>) &#123;</div><div class="line">      <span class="keyword">self</span>.rows = rows</div><div class="line">      <span class="keyword">self</span>.columns = columns</div><div class="line">      grid = <span class="type">Array</span>(<span class="built_in">count</span>: rows * columns, repeatedValue: <span class="number">0.0</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">indexIsValidForRow</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; column &gt;= <span class="number">0</span> &amp;&amp; column &lt; columns</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">subscript</span>(row: <span class="type">Int</span>, column: <span class="type">Int</span>) -&gt; <span class="type">Double</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="built_in">assert</span>(indexIsValidForRow(row, column: column), <span class="string">"Index out of range"</span>)</div><div class="line">            <span class="keyword">return</span> grid[(row * columns) + column]</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            <span class="built_in">assert</span>(indexIsValidForRow(row, column: column), <span class="string">"Index out of range"</span>)</div><div class="line">            grid[(row * columns) + column] = newValue</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> matrix = <span class="type">Matrix</span>(rows: <span class="number">2</span>, columns: <span class="number">2</span>)</div><div class="line"><span class="built_in">println</span>(matrix[<span class="number">0</span>, <span class="number">1</span>])</div><div class="line"><span class="comment">//0.0</span></div><div class="line">matrix[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">1.5</span></div><div class="line"><span class="built_in">println</span>(matrix[<span class="number">0</span>, <span class="number">1</span>])</div><div class="line"><span class="comment">//1.5</span></div></pre></td></tr></table></figure></p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍Swift的基础知识：枚举，结构体和类的属性，方法和下标。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="http://aidaiz.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://aidaiz.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础入门(6)：枚举，类和结构体</title>
    <link href="http://aidaiz.com/swift_6/"/>
    <id>http://aidaiz.com/swift_6/</id>
    <published>2015-07-19T14:47:43.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍Swift的基础知识：枚举，类和结构体的基本概念和语法。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/swift_6" target="_blank" rel="external">Swift基础入门(6)：枚举，类和结构体</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x61;&#105;&#x64;&#x61;&#x69;&#122;&#x79;&#121;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#x61;&#105;&#x64;&#x61;&#x69;&#122;&#x79;&#121;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-07-24</a></strong></p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="枚举语法"><a href="#枚举语法" class="headerlink" title="枚举语法"></a>枚举语法</h2><p>枚举定义了一个通用来兴的一组相关的值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">North</span>, <span class="type">South</span></div><div class="line">    <span class="keyword">case</span> <span class="type">East</span></div><div class="line">    <span class="keyword">case</span> <span class="type">West</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>enum</code>关键字把枚举的整个定义放在大括号中，<code>CompassPoint</code>是它的名称。<code>case</code>表明新的一行成员值被定义，同一行中可以定义多个成员值，用<code>,</code>隔开，这里的成员值为<code>North</code>，<code>South</code>，<code>East</code>，<code>West</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> directionToHead = <span class="type">CompassPoint</span>.<span class="type">West</span></div><div class="line">directionToHead = .<span class="type">East</span></div></pre></td></tr></table></figure></p>
<p>变量的类型经过第一次赋值确定后，再次赋值可省略枚举类型名称，这里<code>directionToHead</code>已经被确定为<code>CompassPoint</code>的成员值，再次赋值用<code>.East</code>的形式就可以了。<br>定义的枚举成员是没有值的，不会自动分配值。后面会介绍存储原始值，不仅可以存储整数，也可以存储浮点数字符串等其他类型。</p>
<h2 id="成员值"><a href="#成员值" class="headerlink" title="成员值"></a>成员值</h2><p>枚举类型用<code>switch</code>匹配时，必须每个成员值都考虑到，否则编译无法通过，可用<code>default</code>替代其他成员值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">directionToHead = .<span class="type">South</span></div><div class="line"><span class="keyword">switch</span> directionToHead &#123;</div><div class="line"><span class="keyword">case</span> .<span class="type">North</span>:</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Lots of planets have a north"</span>)</div><div class="line"><span class="keyword">case</span> .<span class="type">South</span>:</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Watch out for penguins"</span>)</div><div class="line"><span class="keyword">case</span> .<span class="type">East</span>:</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Where the sun rises"</span>)</div><div class="line"><span class="keyword">case</span> .<span class="type">West</span>:</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Where the skies are blue"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 输出 "Watch out for penguins”</span></div></pre></td></tr></table></figure></p>
<h2 id="相关值"><a href="#相关值" class="headerlink" title="相关值"></a>相关值</h2><p>枚举类型的用法比较像C语言中的联合体（<em>union</em>），可以为成员值提供其他类型的相关值，即成员值之外的自定义信息。<br>相关值可以是任何类型，每个成员的数据类型也可以不一样。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">UPCA</span>(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</div><div class="line">  <span class="keyword">case</span> <span class="type">QRCode</span>(<span class="type">String</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>枚举类型<code>Barcode</code>有两个成员值，一个是<code>UPCA</code>，它的相关值是<code>(Int, Int, int)</code>，一个是<code>QRCode</code>，它的相关值是<code>(String)</code><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> productBarcode = <span class="type">Barcode</span>.<span class="type">UPCA</span>(<span class="number">8</span>, <span class="number">85909_51226</span>, <span class="number">3</span>)</div><div class="line">productBarcode = .<span class="type">QRCode</span>(<span class="string">"ABCDEFGHIJKLMNOP"</span>)</div></pre></td></tr></table></figure></p>
<h1 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h1><p>类（<em>Class</em>）和结构体（<em>Struct</em>）的用法和其他语言类似。<br>主要区别在于，类允许继承，而结构体不行；类是引用传递，而结构体是值传递。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> height = <span class="number">0</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> resolution = <span class="type">Resolution</span>()</div><div class="line">    <span class="keyword">var</span> interlaced = <span class="literal">false</span></div><div class="line">    <span class="keyword">var</span> frameRate = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> someResolution = <span class="type">Resolution</span>(width: <span class="number">1920</span>, height: <span class="number">1080</span>)</div><div class="line"><span class="keyword">let</span> someVideoMode = <span class="type">VideoMode</span>()</div><div class="line">someVideoMode.resolution = someResolution;</div><div class="line">someVideoMode.interlaced = <span class="literal">true</span>;</div><div class="line">someVideoMode.name = <span class="string">"1080i"</span></div><div class="line">someVideoMode.frameRate = <span class="number">25.0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> otherResolution = someResolution;</div><div class="line"><span class="keyword">let</span> otherVideoMode = someVideoMode;</div><div class="line"></div><div class="line">someResolution.width = <span class="number">2048</span></div><div class="line"><span class="built_in">println</span>(<span class="string">"someResolution is now  \(someResolution.width) pixels wide"</span>)</div><div class="line"><span class="comment">// 输出 "someResolution is now 2048 pixels wide"</span></div><div class="line"><span class="built_in">println</span>(<span class="string">"otherResolution is now  \(otherResolution.width) pixels wide"</span>)</div><div class="line"><span class="comment">// 输出 "otherResolution is now 1920 pixels wide"</span></div><div class="line"></div><div class="line">someVideoMode.resolution.width = <span class="number">1280</span></div><div class="line"><span class="built_in">println</span>(<span class="string">"The width of someVideoMode is now \(someVideoMode.resolution.width)"</span>)</div><div class="line"><span class="comment">// 输出 "The width of someVideoMode is now 1280"</span></div><div class="line"><span class="built_in">println</span>(<span class="string">"The width of otherVideoMode is now \(otherVideoMode.resolution.width)"</span>)</div><div class="line"><span class="comment">// 输出 "The width of otherVideoMode is now 1280"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> someVideoMode === otherVideoMode &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"someVideoMode and otherVideoMode refer to the same VideoMode instance."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出 "someVideoMode and otherVideoMode refer to the same VideoMode instance."</span></div></pre></td></tr></table></figure>
<p>第1-10行是类和结构体的定义，分别用<code>class</code>和<code>struct</code>表示。</p>
<p>第12-17行是给类和结构体创建实例，并赋值。<br>结构体可以在构造时逐一初始化成员，<code>(width: 1920, height: 1080)</code>，而类不可以。</p>
<p>第19-20行，分别用类和结构体的实例去赋值变量或常量。</p>
<p>第22-26行，变量<code>otherResolution</code>被结构体<code>someResolution</code>赋值时采用的是值传递，因此相互是独立的，只是成员值一样。<br>改变了<code>someResolutin</code>的属性<code>width</code>的值后，<code>otherResolution</code>并未受到影响。</p>
<p>第28-32行，常量<code>otherVideoMode</code>被类<code>otherVideoMode</code>赋值时采用的是引用传递，指向的是同一个对象。<br>改变了<code>someVideoMode</code>的属性<code>reoulution.width</code>的值后，<code>otherVideoMode</code>的相应属性也随之变化。<br><code>someVideoMode</code>和<code>otherVideoMode</code>被声明为常量,也可以改变其中的成员属性：<br>因为他们都不存储实例，只存储了引用对象，没有改变引用对象，只改变了被引用的基础<code>VideoMode</code>的成员属性。<br>Swift中，几乎所有的基本类型，包括字符串，数组和字典等都是值传递。</p>
<p>第34-37行，因为两者指向同一对象，不仅仅是成员值相等的关系了，<code>==</code>等于符号并不足以描述这样的关系。<br><code>====</code>恒等运算符用来形容两者指向同一对象，表示两个实例等价。</p>
<p>枚举，类和结构体的其他特性，参见：<br><a href="http://aidaizyy.github.io/swift_7" target="_blank" rel="external">Swift基础入门(7)：属性，方法和下标</a><br><a href="http://aidaizyy.github.io/swift_8" target="_blank" rel="external">Swift基础入门(8)：继承，构造，析构和嵌套类型</a></p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍Swift的基础知识：枚举，类和结构体的基本概念和语法。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="http://aidaiz.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://aidaiz.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础入门(5)：函数和闭包</title>
    <link href="http://aidaiz.com/swift_5/"/>
    <id>http://aidaiz.com/swift_5/</id>
    <published>2015-07-16T09:11:53.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍Swift的基础知识：函数和闭包（Closure）。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/swift_5" target="_blank" rel="external">Swift基础入门(5)：函数和闭包</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#97;&#x69;&#x64;&#x61;&#x69;&#122;&#121;&#x79;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;">&#97;&#x69;&#x64;&#x61;&#x69;&#122;&#121;&#x79;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-07-22</a></strong></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p><code>func functionName(parameters) -&gt; returnType { statements }</code><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">halfOpenRangeLength</span><span class="params">(start: Int, end: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> end - start</div><div class="line">&#125;</div><div class="line"><span class="built_in">println</span>(halfOpenRangeLength(<span class="number">1</span>, <span class="number">10</span>))</div><div class="line"><span class="comment">// prints "9"</span></div></pre></td></tr></table></figure></p>
<p>函数前必须加标识符<code>func</code>，函数名<code>halfOpenRangeLength</code>需要传入两个参数<code>start</code>和<code>end</code>，都是<code>Int</code>类型，返回<code>Int</code>类型。<br>可以没有参数，也可以没有返回值，则写作<code>func halfOpenRangeLength() { statements }</code>，<code>statements</code>中不带<code>return</code>语句。</p>
<p>函数可以有多个返回值，用元组表示返回值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(string: String)</span></span> -&gt; (vowels: <span class="type">Int</span>, consonants: <span class="type">Int</span>, others: <span class="type">Int</span>) &#123;</div><div class="line">    <span class="keyword">var</span> vowels = <span class="number">0</span>, consonants = <span class="number">0</span>, others = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> character <span class="keyword">in</span> string &#123;</div><div class="line">        <span class="keyword">switch</span> <span class="type">String</span>(character).lowercaseString &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"u"</span>:</div><div class="line">            ++vowels</div><div class="line">        <span class="keyword">case</span> <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>, <span class="string">"m"</span>,</div><div class="line">          <span class="string">"n"</span>, <span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">"v"</span>, <span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>:</div><div class="line">            ++consonants</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            ++others</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (vowels, consonants, others)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> total = <span class="built_in">count</span>(<span class="string">"some arbitrary string!"</span>)</div><div class="line"><span class="built_in">println</span>(<span class="string">"\(total.vowels) vowels and \(total.consonants) consonants"</span>)</div><div class="line"><span class="comment">// prints "6 vowels and 13 consonants"</span></div></pre></td></tr></table></figure></p>
<p><code>func count(String) -&gt; (Int, Int, Int)</code>函数，传入一个<code>String</code>值，返回一个带3个<code>Int</code>值的元组。<br>返回的元组成员不需要再命名，因为在函数定义时已经命名了返回元组成员的名称。<br>当然也可以不命名，返回类型写作<code>(Int, Int, Int)</code>的形式，用<code>total.0</code>，<code>total.1</code>和<code>total.2</code>去获取元组<code>total</code>的第1个，第2个和第3个成员的值。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="外部参数名"><a href="#外部参数名" class="headerlink" title="外部参数名"></a>外部参数名</h3><p>函数参数的名称作为局部参数名，只能在函数中使用。定义外部参数名，可以在函数外部使用帮助函数参数的意图清晰，<code>func functionName(externalParameterName localParameterName: dataType) { statements }</code>。<br>注意：但是一旦定义了外部参数名，在函数调用时就<strong>必须使用</strong>。<br>外部参数名和局部参数名如果一致，可在局部参数名前加<code>#</code>表示，<code>func functionName(#parameterName: dataType) { statements }</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsCharacter</span><span class="params">(str string: String, #characterToFind: Character)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">for</span> character <span class="keyword">in</span> string &#123;</div><div class="line">        <span class="keyword">if</span> character == characterToFind &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> containsAVee = containsCharacter(str: <span class="string">"aardvark"</span>, characterToFind: <span class="string">"v"</span>)</div><div class="line"><span class="comment">// containsAVee equals true, because "aardvark" contains a "v”</span></div></pre></td></tr></table></figure></p>
<h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>函数参数可以定义默认值，但必须在函数参数列表的最后。调用时，如果不指定参数的值，则使用默认值。<br>定义了默认值的函数参数会自动提供外部参数名，和局部参数名一样，也可以自己提供，如果不使用默认值，则必须在调用时使用外部参数名。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">join</span><span class="params">(s1: String, s2: String, joiner: String = <span class="string">" "</span>, flag: String = <span class="string">"!"</span>)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">return</span> s1 + joiner + s2 + flag</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">join</span>(<span class="string">"hello"</span>, <span class="string">"world"</span>, joiner: <span class="string">"-"</span>)</div><div class="line"><span class="comment">// returns "hello-world!"</span></div></pre></td></tr></table></figure></p>
<p>第3个参数<code>joiner</code>和第四个参数<code>flag</code>都是提供了默认参数值，自动提供了外部参数名<code>joiner</code>和<code>flag</code>，与局部参数名一致。<br><code>joiner</code>提供了值，则必须使用参数名<code>joiner: &quot;-&quot;</code>。<br><code>flag</code>使用默认值，则不需要在调用时出现。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数（<em>variadic parameter</em>）表示不确定数量的输入参数，在参数后加<code>...</code>表示。一个函数最多只能有一个可变参数， 且必须是参数列表的最后一个参数。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">arithmeticMean</span><span class="params">(numbers: Double...)</span></span> -&gt; <span class="type">Double</span> &#123;</div><div class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</div><div class="line">        total += number</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> total / <span class="type">Double</span>(numbers.<span class="built_in">count</span>)</div><div class="line">&#125;</div><div class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line"><span class="comment">// returns 3.0, which is the arithmetic mean of these five numbers</span></div><div class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8</span>, <span class="number">19</span>)</div><div class="line"><span class="comment">// returns 10.0, which is the arithmetic mean of these three numbers</span></div></pre></td></tr></table></figure></p>
<h3 id="变量参数"><a href="#变量参数" class="headerlink" title="变量参数"></a>变量参数</h3><p>Swift的函数参数采用值拷贝传递，传递进去的参数是不能进行修改的，如果我们需要，可以定义变量参数。在参数前加<code>var</code>定义变量参数。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendCharacter</span><span class="params">(<span class="keyword">var</span> string: String, flag: Character)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    string.append(flag)</div><div class="line">    <span class="keyword">return</span> string</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> originalString = <span class="string">"hello"</span></div><div class="line"><span class="keyword">let</span> paddedString = appendCharacter(originalString, <span class="string">"!"</span>)</div><div class="line"><span class="comment">// paddedString is equal to "hello!"</span></div></pre></td></tr></table></figure></p>
<p><code>string</code>在函数内被修改了，但是作为局部变量，只能在函数内部使用。</p>
<h3 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h3><p>Swift的函数参数不能被修改，使用变量参数修改后也不能传递到外部，采用输入输出参数可以解决这个问题。<br>在参数前加<code>inout</code>定义输入输出参数。</p>
<ul>
<li>函数调用时，输入输出参数只能传入变量</li>
<li>输入输出参数不能有默认参数值。</li>
<li>输入输出参数不能是可变参数。<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendCharacter</span><span class="params">(<span class="keyword">inout</span> string: String, flag: Character)</span></span> &#123;</div><div class="line">    string.append(flag)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> originalString = <span class="string">"hello"</span></div><div class="line">appendCharacter(&amp;originalString, <span class="string">"!"</span>)</div><div class="line"><span class="comment">// originalString is equal to "hello!"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>appendCharacter</code>函数传入参数时，在输入输出参数前必须加<code>&amp;</code>前缀。</p>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>函数类型和其他类型一样，可以定义并赋值，如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoInts</span><span class="params">(a: Int, b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> mathFunciton1: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> =addTwoInts</div><div class="line"></div><div class="line"><span class="keyword">var</span> mathFunciton2 = addTwoInts		<span class="comment">//通过赋值自动判断mathFunction类型为函数类型</span></div><div class="line"></div><div class="line"><span class="built_in">println</span>(<span class="string">"Result: \(mathFunction1(2, 3))"</span>)</div><div class="line"><span class="comment">// prints "Result: 5"</span></div><div class="line"><span class="built_in">println</span>(<span class="string">"Result: \(mathFunction2(2, 3))"</span>)</div><div class="line"><span class="comment">// prints "Result: 5"</span></div></pre></td></tr></table></figure></p>
<p>同样函数类型可以作为函数的参数类型和返回类型，形式如<code>func printMathResult(mathFunction: (Int, Int) -&gt; Int, a: Int, b: Int)</code>和<code>func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int</code>。前者的一个参数为<code>mathFunction: (Int, Int) -&gt; Int</code>，后者的返回<code>(Int) -&gt; Int</code>，都没有<code>func</code>关键字。</p>
<p>函数也支持嵌套函数，在函数A内部定义的函数B只能在函数A内调用。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h2><p>闭包指自包含的函数代码块，可以在代码中被传递和使用。<br>函数就是特殊的闭包。<br>闭包的一般形式：<code>{ (parameters) -&gt; returnType in statements }
和函数不同的是，用</code>in`替代了原本函数的大括号，并在最外层加上大括号。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">backwards</span><span class="params">(s1: String, s2: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> s1 &gt; s2</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> reversed = sorted(names, backwards)</div><div class="line"><span class="comment">// reversed 为 ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span></div></pre></td></tr></table></figure></p>
<p><code>sorted</code>函数需要两个参数，第一个参数是需要排序的数组，第二个参数是确定排序顺序的闭包函数，传入与数组类型相同的两个值，并返回<code>Bool</code>值。如果第二个参数返回<code>true</code>则两个数组元素顺序不变；如果第二个参数返回<code>false</code>则两个数组元素顺序相反。<br>所以闭包函数中定义<code>return s1 &gt; s2</code>，如果<code>s1</code>大于<code>s2</code>顺序不变，如果<code>s1</code>不大于<code>s2</code>则交换<code>s1</code>和<code>s2</code>的顺序，使值大的元素排在数组的前列，也就是逆序排列。<br>就上面的代码改为闭包表达式的形式为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reversed = sorted(names, &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> s1 &gt; s2</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>用闭包表达式代替了闭包函数，<code>in</code>替换函数的大括号，并在外层添加大括号。</p>
<p>闭包表达式的参数类型由第一个参数数组元素的类型决定，返回类型确定为<code>Bool</code>型，创建闭包时可以省略已知的信息：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversed = sorted(names, &#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125;)</div></pre></td></tr></table></figure></p>
<p>闭包表达式中，如果只有单行表达式，比如<code>return s1 &gt; s2</code>一行，可以省略<code>return</code>关键字：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversed = sorted(names, &#123; s1, s2 <span class="keyword">in</span> s1 &gt; s2 &#125;)</div></pre></td></tr></table></figure></p>
<p>闭包表达式的参数名称可以缩写成$0，$1，$2等，来顺序调用闭包参数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversed = sorted(names, &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;)</div></pre></td></tr></table></figure></p>
<p>另外，还可以用运算符函数（operator function）使闭包表达式更简短。因为<code>&gt;</code>的定义就是接收两个参数，并返回<code>Bool</code>类型值，所以可以写：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversed = sorted(names, &gt;)</div></pre></td></tr></table></figure></p>
<p>尾随闭包（trailing closure）：如果闭包表达是是函数的最后一个参数，可以把闭包放到函数的小括号后面，增强可读性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reversed = sorted(names, &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;)	<span class="comment">//闭包表达式</span></div><div class="line"></div><div class="line">reversed = sorted(names) &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;	<span class="comment">//尾随闭包</span></div></pre></td></tr></table></figure></p>
<p>如果闭包很长，尾随闭包就会非常有用。<br>如果函数中只有闭包一个参数，则可以省略小括号，写成<code>reversed = sorted { $0 &lt; $1 }</code>的形式。</p>
<h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><p>嵌套函数是最简单的闭包形式。嵌套函数可以捕获外部函数的参数和定义的常量变量。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementor</span><span class="params">(forIncrement amount: Int)</span></span> -&gt; () -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">var</span> runningTotal = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        runningTotal += amount</div><div class="line">        <span class="keyword">return</span> runningTotal</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> incrementor</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>incrementor</code>函数调用的<code>amount</code>是外部函数的参数，捕获并存储了副本；<code>runningTotal</code>会被修改，所以不可以是副本，而是捕获了一个引用，就算外部函数结束都不会消失。Swift会自动决定捕获引用还是副本。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> incrementByTen = makeIncrementor(forIncrement: <span class="number">10</span>)</div><div class="line"></div><div class="line">incrementByTen()</div><div class="line"><span class="comment">// 返回的值为10</span></div><div class="line">incrementByTen()</div><div class="line"><span class="comment">// 返回的值为20</span></div><div class="line">incrementByTen()</div><div class="line"><span class="comment">// 返回的值为30</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> incrementBySeven = makeIncrementor(forIncrement: <span class="number">7</span>)</div><div class="line">incrementBySeven()</div><div class="line"><span class="comment">// 返回的值为7</span></div><div class="line">incrementByTen()</div><div class="line"><span class="comment">// 返回的值为40</span></div></pre></td></tr></table></figure></p>
<p><code>incrementByTen</code>创建时，<code>runningTotal</code>也创建了，每调用一次函数其值就会增加10。<br><code>incremetnBySeven</code>创建时，一个新的<code>runningTotal</code>也创建了，每调用一次函数其值就会增加7。这个变量和<code>incrementByTen</code>中的变量没有任何关系，互不干扰。</p>
<p>注意：无论是函数还是闭包，在赋值给常量或变量时都是<strong>引用拷贝</strong>，指向的是同一个函数/闭包对象。</p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍Swift的基础知识：函数和闭包（Closure）。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="http://aidaiz.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://aidaiz.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础入门(4)：条件与循环语句</title>
    <link href="http://aidaiz.com/swift_4/"/>
    <id>http://aidaiz.com/swift_4/</id>
    <published>2015-07-16T06:36:11.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍Swift的基础知识：条件语句和循环语句。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/swift_4" target="_blank" rel="external">Swift基础入门(4)：条件与循环语句</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#97;&#x69;&#x64;&#x61;&#105;&#x7a;&#121;&#121;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">&#97;&#x69;&#x64;&#x61;&#105;&#x7a;&#121;&#121;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-07-16</a></strong></p>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</div><div class="line">	<span class="built_in">println</span>(index)</div><div class="line">&#125;</div><div class="line"><span class="comment">//1</span></div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="comment">//3</span></div><div class="line"><span class="comment">//4</span></div><div class="line"><span class="comment">//5</span></div></pre></td></tr></table></figure>
<p><code>for-in</code>循环可用于区间。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> res = <span class="number">1</span></div><div class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</div><div class="line">	res *= <span class="number">2</span></div><div class="line">	<span class="built_in">println</span>(res)</div><div class="line">&#125;</div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="comment">//4</span></div><div class="line"><span class="comment">//8</span></div><div class="line"><span class="comment">//16</span></div><div class="line"><span class="comment">//32</span></div></pre></td></tr></table></figure></p>
<p>如果不需要区间中每项的值，可以用<code>_</code>替代。<br><code>for-in</code>用于字符串，请见<a href="http://aidaizyy.github.io/swift_2" target="_blank" rel="external">Swift基础入门(2)</a>。<br><code>for-in</code>用于数组集合字典，请见<a href="http://aidaizyy.github.io/swift_3" target="_blank" rel="external">Swift基础入门(3)</a>。</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p><code>for</code>循环和C语言一致，格式为<code>for initialization; condition; increment { statements }</code>，区别在于没有括号。</p>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p><code>while</code>循环和C语言一致，格式为<code>while condition { statements }</code>，区别在于没有括号。</p>
<h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h2><p><code>do-while</code>循环和C语言一致，格式为<code>do { statements } while condition</code>，区别在于没有括号。</p>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p><code>if</code>语句和C语言一直，格式为<code>if condition { statements } else if condition { statements } else { statesments },区别在于没有括号，</code>else if<code>和</code>else`不是必须存在。</p>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">300</span></div><div class="line"><span class="keyword">var</span> naturalCount: <span class="type">String</span></div><div class="line"><span class="keyword">switch</span> <span class="built_in">count</span> &#123;</div><div class="line"><span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">    naturalCount = <span class="string">"no"</span></div><div class="line"><span class="keyword">case</span> <span class="number">1</span>...<span class="number">3</span>:</div><div class="line">    naturalCount = <span class="string">"a few"</span></div><div class="line"><span class="keyword">case</span> <span class="number">4</span>...<span class="number">9</span>:</div><div class="line">    naturalCount = <span class="string">"several"</span></div><div class="line"><span class="keyword">case</span> <span class="number">10</span>...<span class="number">99</span>:</div><div class="line">    naturalCount = <span class="string">"tens of"</span></div><div class="line"><span class="keyword">case</span> <span class="number">100</span>...<span class="number">999</span>:</div><div class="line">    naturalCount = <span class="string">"hundreds of"</span></div><div class="line"><span class="keyword">case</span> <span class="number">1000</span>...<span class="number">999_999</span>:</div><div class="line">    naturalCount = <span class="string">"thousands of"</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line">    naturalCount = <span class="string">"millions and millions of"</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">println</span>(<span class="string">"There are \(naturalCount) stars in the Milky Way."</span>)</div><div class="line"><span class="comment">// 输出 "There are hundreds of stars in the Milk Way."</span></div></pre></td></tr></table></figure>
<p>在C语言中，通常使用<code>break</code>，避免执行了一个<code>case</code>语句后继续执行下一个<code>case</code>语句。在Swift语言中不需要添加<code>break</code>，<code>switch</code>语句只执行最前面一个符合条件的<code>case</code>语句。<br><code>case</code>语句可以接类似于<code>1...3</code>的区间。<br><code>case</code>语句可以接多个情况，用逗号隔开，<code>switch value { case value1, value2: statements }</code></p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> somePoint = (<span class="number">1</span>, <span class="number">1</span>)</div><div class="line"><span class="keyword">switch</span> somePoint &#123;</div><div class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):</div><div class="line">    <span class="built_in">println</span>(<span class="string">"(0, 0) is at the origin"</span>)</div><div class="line"><span class="keyword">case</span> (<span class="number">_</span>, <span class="number">0</span>):</div><div class="line">    <span class="built_in">println</span>(<span class="string">"(\(somePoint.0), 0) is on the x-axis"</span>)</div><div class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">_</span>):</div><div class="line">    <span class="built_in">println</span>(<span class="string">"(0, \(somePoint.1)) is on the y-axis"</span>)</div><div class="line"><span class="keyword">case</span> (-<span class="number">2</span>...<span class="number">2</span>, -<span class="number">2</span>...<span class="number">2</span>):</div><div class="line">    <span class="built_in">println</span>(<span class="string">"(\(somePoint.0), \(somePoint.1)) is inside the box"</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="built_in">println</span>(<span class="string">"(\(somePoint.0), \(somePoint.1)) is outside of the box"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 输出 "(1, 1) is inside the box"</span></div><div class="line">``` </div><div class="line">元组也可以用来判断条件，`<span class="number">_</span>`用来匹配所有可能的值，也就是需要忽略的值。</div><div class="line"></div><div class="line">## 值绑定</div><div class="line">``` swift</div><div class="line"><span class="keyword">let</span> anotherPoint = (<span class="number">2</span>, <span class="number">0</span>)</div><div class="line"><span class="keyword">switch</span> anotherPoint &#123;</div><div class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>):</div><div class="line">    <span class="built_in">println</span>(<span class="string">"on the x-axis with an x value of \(x)"</span>)</div><div class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y):</div><div class="line">    <span class="built_in">println</span>(<span class="string">"on the y-axis with a y value of \(y)"</span>)</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</div><div class="line">    <span class="built_in">println</span>(<span class="string">"somewhere else at (\(x), \(y))"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>case</code>语句中，可以用临时的常量变量去绑定值并使用。</p>
<h2 id="额外条件（Where语句）"><a href="#额外条件（Where语句）" class="headerlink" title="额外条件（Where语句）"></a>额外条件（Where语句）</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> yetAnotherPoint = (<span class="number">1</span>, -<span class="number">1</span>)</div><div class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == y:</div><div class="line">    <span class="built_in">println</span>(<span class="string">"(\(x), \(y)) is on the line x == y"</span>)</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == -y:</div><div class="line">    <span class="built_in">println</span>(<span class="string">"(\(x), \(y)) is on the line x == -y"</span>)</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</div><div class="line">    <span class="built_in">println</span>(<span class="string">"(\(x), \(y)) is just some arbitrary point"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 输出 "(1, -1) is on the line x == -y"</span></div></pre></td></tr></table></figure>
<p><code>case</code>语句中可以使用<code>where</code>语句跟在条件后作为额外的补充条件，需要同时满足两个条件才可以执行。</p>
<h1 id="控制转移语句"><a href="#控制转移语句" class="headerlink" title="控制转移语句"></a>控制转移语句</h1><p>Swift一共有四种控制转移语句：<br>-continue<br>-break<br>-fallthrough<br>-return</p>
<p><code>continue</code>，<code>break</code>和<code>return</code>用法和C语言基本一致。<br>在<code>switch</code>语句中，<code>continue</code>和<code>break</code>都针对整个<code>switch</code>语句，而不是C语言中的一个<code>case</code>语句。遇到<code>break</code>后直接退出整个<code>switch</code>语句，而不是判断下一个<code>case</code>，<code>continue</code>同理。</p>
<h2 id="贯穿语句（Fallthrough语句）"><a href="#贯穿语句（Fallthrough语句）" class="headerlink" title="贯穿语句（Fallthrough语句）"></a>贯穿语句（Fallthrough语句）</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> integerToDescribe = <span class="number">5</span></div><div class="line"><span class="keyword">var</span> description = <span class="string">"The number \(integerToDescribe) is"</span></div><div class="line"><span class="keyword">switch</span> integerToDescribe &#123;</div><div class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>:</div><div class="line">    description += <span class="string">" a prime number, and also"</span></div><div class="line">    <span class="keyword">fallthrough</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line">    description += <span class="string">" an integer."</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">println</span>(description)</div><div class="line"><span class="comment">// 输出 "The number 5 is a prime number, and also an integer."</span></div></pre></td></tr></table></figure>
<p>Swift语言不支持在<code>switch</code>语句中贯穿多个<code>case</code>语句的情况，但有时我们需要这么做。这时我们可以加上关键字<code>fallthrough</code>，当遇到<code>fallthrough</code>时，就会继续执行下一个<code>case</code>语句。<br>注意：遇到<code>fallthrough</code>时会直接<strong>执行</strong>下一个<code>case</code>语句，而不是去<strong>判断</strong>条件。</p>
<h2 id="精确控制转移"><a href="#精确控制转移" class="headerlink" title="精确控制转移"></a>精确控制转移</h2><p>Swift语言中可以让<code>break</code>和<code>continue</code>精确地表示针对哪一个循环或条件语句，这称为带标签的语句（<em>Labeled Statements</em>）。<br><code>label name: while condition { statements }</code>，之后再执行<code>break label name</code>或<code>continue label name</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//求第一个质数</span></div><div class="line">loop: <span class="keyword">for</span> integer <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</div><div class="line">    <span class="keyword">switch</span> integer &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>:</div><div class="line">        <span class="built_in">println</span>(<span class="string">"\(integer) is a prime number"</span>)</div><div class="line">        <span class="keyword">break</span> loop</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">println</span>(<span class="string">"\(integer) is not a prime number"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，给<code>for-in</code>循环指定了标签<code>loop</code>，我们要求得到第一个质数，所以当遇到质数后用<code>break loop</code>结束循环。如果不加标签，<code>break</code>只能结束<code>switch</code>语句，会继续执行循环，不能达到目的。</p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍Swift的基础知识：条件语句和循环语句。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="http://aidaiz.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://aidaiz.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础入门(3)：数组，集合和字典</title>
    <link href="http://aidaiz.com/swift_3/"/>
    <id>http://aidaiz.com/swift_3/</id>
    <published>2015-07-15T09:04:30.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍Swift的基础知识：数组（Array），集合（Set）和字符（Dictionary）。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/swift_3" target="_blank" rel="external">Swift基础入门(3)：数组，集合和字典</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x61;&#x69;&#100;&#x61;&#x69;&#x7a;&#121;&#x79;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">&#x61;&#x69;&#100;&#x61;&#x69;&#x7a;&#121;&#x79;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-07-16</a></strong></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shoppinglist = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]	<span class="comment">//初始化为字符串数组，没有指定数据类型，通过添加数据自动判断为String数组</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> someInts1 = [<span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="keyword">var</span> someInts2: [<span class="type">Int</span>] = [<span class="number">2</span>, <span class="number">3</span>]		<span class="comment">//等价于上一句，初始化为整数数组，指定了数据类型Int，只能添加Int数据，并添加了元素2，3</span></div><div class="line"><span class="keyword">var</span> someInts3: <span class="type">Array</span>&lt;<span class="type">Int</span>&gt; = [<span class="number">2</span>, <span class="number">3</span>]	<span class="comment">//等价于上一句</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> someInts4 = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()		<span class="comment">//初始化为整数数组，指定了数据类型Int，只能添加Int数据，没有添加元素</span></div><div class="line"><span class="keyword">var</span> someInts5 = [<span class="type">Int</span>]()			<span class="comment">//等价于上一句</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> someDoubles = []			<span class="comment">//初始化为空数组，没有指定数据类型，通过添加数据自动判断</span></div><div class="line">someDoubles.append(<span class="number">2.3</span>)			<span class="comment">//通过添加数据自动判断为Double数组</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> threeDoubles = [<span class="type">Double</span>](<span class="built_in">count</span>: <span class="number">3</span>, repeatedValue: <span class="number">0.0</span>)</div><div class="line"><span class="comment">//(count: , repeatedValue: )形式，指定了重复的值和重复的次数，构造数组&#123;0.0, 0.0, 0.0&#125;</span></div></pre></td></tr></table></figure>
<p>数组的元素只能有一种数据类型。</p>
<h2 id="数量"><a href="#数量" class="headerlink" title="数量"></a>数量</h2><ul>
<li>Array.count：属性<code>count</code>表示数组<code>Array</code>的元素个数。</li>
<li>Array.isEmpty：属性<code>isEmpty</code>表示数组<code>Array</code>的元素是否为0个，结果为<code>true</code>或<code>false</code>。</li>
</ul>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><ul>
<li>Array[i]：通过下标<code>[i]</code>访问数组<code>Array</code>的第<code>i</code>位，可修改。</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shoppinglist = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> shoppingList &#123;</div><div class="line">	<span class="built_in">println</span>(item)</div><div class="line">&#125;</div><div class="line"><span class="comment">//Eggs</span></div><div class="line"><span class="comment">//Milk</span></div></pre></td></tr></table></figure>
<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><ul>
<li>Array.append(Item)：将元素<code>Item</code>添加到数组<code>Array</code>的尾部。</li>
<li>Array.imsert(Item, atIndex: i)：将元素<code>Item</code>添加到数组<code>Array</code>的第<code>i</code>位。</li>
<li>Array += [Item1, Item2]：将元素<code>Item1</code>和<code>Item2</code>添加到数组<code>Array</code>的尾部。</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li>Array.removeAtIndex(i)：删除数组<code>Array</code>的第<code>i</code>位。</li>
<li>Array.removeLast()：删除数组<code>Array</code>的最后一位。</li>
</ul>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><ul>
<li>Array[m…n] = [Item1, Item2]：用元素<code>Item1</code>和<code>Item2</code>替换数组<code>Array</code>的第<code>m</code>位到第<code>n</code>位。这种方法不能用于添加新元素。</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合中的元素没有确定顺序，且每个元素只出现一次。</p>
<h2 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shoppinglist: <span class="type">Set</span> = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]	<span class="comment">//初始化为字符串集合，没有指定数据类型，通过添加数据自动判断为String集合</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> someInts1: <span class="type">Set</span> = [<span class="number">2</span>, <span class="number">3</span>]			</div><div class="line"><span class="keyword">var</span> someInts2: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; = [<span class="number">2</span>, <span class="number">3</span>]		<span class="comment">//等价于上一句，初始化为整数集合，指定了数据类型Int，只能添加Int数据，并添加了元素2，3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> someInts3 = <span class="type">Set</span>&lt;<span class="type">Int</span>&gt;()			<span class="comment">//初始化为整数集合，指定了数据类型Int，只能添加Int数据，没有添加元素</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> someDoubles: <span class="type">Set</span> = []			<span class="comment">//初始化为空集合，没有指定数据类型，通过添加数据自动判断</span></div><div class="line">someDoubles.insert(<span class="number">2.3</span>)				<span class="comment">//通过添加数据自动判断为Double集合</span></div></pre></td></tr></table></figure>
<p>集合的元素只能有一种数据类型。</p>
<h2 id="数量-1"><a href="#数量-1" class="headerlink" title="数量"></a>数量</h2><ul>
<li>Set.count：属性<code>count</code>表示集合<code>Set</code>的元素个数。</li>
<li>Set.isEmpty：属性<code>isEmpty</code>表示集合<code>Set</code>的元素是否为0个，结果为<code>true</code>或<code>false</code>。</li>
</ul>
<h2 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shoppinglist1: <span class="type">Set</span> = [<span class="string">"Milk"</span>, <span class="string">"Eggs"</span>]</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> shoppingList &#123;</div><div class="line">	<span class="built_in">println</span>(item)</div><div class="line">&#125;</div><div class="line"><span class="comment">//Milk</span></div><div class="line"><span class="comment">//Eggs</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> shoppinglist2: <span class="type">Set</span> = [<span class="string">"Milk"</span>, <span class="string">"Eggs"</span>]</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> sorted(shoppingList) &#123;</div><div class="line">	<span class="built_in">println</span>(item)</div><div class="line">&#125;</div><div class="line"><span class="comment">//Eggs</span></div><div class="line"><span class="comment">//Milk</span></div></pre></td></tr></table></figure>
<p>因为<code>Set</code>中没有确定顺序，可以通过<code>sorted(Set)</code>函数返回一个排序的集合。</p>
<h2 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h2><ul>
<li>Set.imsert(Item)：将元素<code>Item</code>添加到集合<code>Set</code>中。</li>
</ul>
<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><ul>
<li>Set.remove(Item)：删除集合<code>Set</code>中的元素<code>Item</code>，成功则返回<code>Item</code>，如果集合中不包含<code>Item</code>则返回<code>nil</code>。</li>
<li>Set.removeAll()：删除集合<code>Set</code>中的所有元素</li>
</ul>
<h2 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h2><ul>
<li>Set.contains(Item)：检查集合<code>Set</code>是否包含元素<code>Item</code>，返回<code>true</code>或<code>false</code>。</li>
</ul>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s1: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">2</span>]</div><div class="line"><span class="keyword">let</span> s2: <span class="type">Set</span> = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</div><div class="line"><span class="keyword">let</span> cityAnimals: <span class="type">Set</span> = [<span class="number">6</span>, <span class="number">7</span>]</div><div class="line">s1.isSubsetOf(s2)</div><div class="line"><span class="comment">// true</span></div><div class="line">s2.isSuperSetOf(s1)</div><div class="line"><span class="comment">// true</span></div><div class="line">s2.isDisjointWith(s3)</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<ul>
<li>==：判断两个集合是否相等</li>
<li>Set1.isSubsetOf(Set2)：判断<code>Set1</code>是否是<code>Set2</code>的子集</li>
<li>Set1.isSupersetOf(Set2)：判断<code>Set1</code>是否是<code>Set2</code>的父集</li>
<li>Set1.isStrictSubsetOf(Set2)，Set1.isStrictSupersetOf(Set2)：和上面方法相似，不过两个集合不能相等。</li>
<li>Set1.isDisjoinWith(Set2)：判断<code>Set1</code>和<code>Set2</code>是否完成没有一个相同元素<br>上述方法都返回<code>true</code>或<code>false</code>。</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> oddDigits: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</div><div class="line"><span class="keyword">let</span> evenDigits: <span class="type">Set</span> = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</div><div class="line"><span class="keyword">let</span> singleDigitPrimeNumbers: <span class="type">Set</span> = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</div><div class="line">sorted(oddDigits.union(evenDigits))</div><div class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></div><div class="line">sorted(oddDigits.intersect(evenDigits))</div><div class="line"><span class="comment">// []</span></div><div class="line">sorted(oddDigits.subtract(singleDigitPrimeNumbers))</div><div class="line"><span class="comment">// [1, 9]</span></div><div class="line">sorted(oddDigits.exclusiveOr(singleDigitPrimeNumbers))</div><div class="line"><span class="comment">// [1, 2, 9]</span></div></pre></td></tr></table></figure>
<ul>
<li>Set1.intersects(Set2)：返回<code>Set1</code>和<code>Set2</code>的交集，即两个集合中都有的元素</li>
<li>Set1.union(Set2)：返回<code>Set1</code>和<code>Set2</code>的并集，即两个集合中的所有元素</li>
<li>Set1.subtract(Set2)：返回<code>Set1</code>和<code>Set2</code>的差集，即<code>Set1</code>中有的且<code>Set2</code>中没有的元素</li>
<li>Set1.exclusiverOr(Set2)：返回并集减去并集的集合，即<code>Set1</code>中独有的和<code>Set2</code>中独有的元素，也就是所有元素减去两个集合中都有的元素。</li>
</ul>
<h2 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h2><p>Swift中的所有基本类型默认都是可哈希的，通过<code>a.hashValue</code>求得哈希值。哈希值相等可以判断对象相同，如<code>a == b</code>即<code>a.hashValue == b.hashValue</code>。</p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典中每个值（<em>Value</em>）都关联唯一的建（<em>key</em>）。</p>
<h2 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h2><p>在构造过程中，键值对默认用<code>[key 1: value 1, key 2: value 2, key 3: value 3]</code>的形式。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> airports1 = [<span class="string">"TYO"</span>: <span class="string">"Tokyo"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]				<span class="comment">//初始化为[String: String]字典，没有指定数据类型，通过添加数据自动判断</span></div><div class="line"><span class="keyword">var</span> airports2: [<span class="type">String</span>: <span class="type">String</span>] = [<span class="string">"TYO"</span>: <span class="string">"Tokyo"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]		<span class="comment">//等价于上一句</span></div><div class="line"><span class="keyword">var</span> airports3: <span class="type">Dictionary</span>&lt;<span class="type">Stringr</span>, <span class="type">String</span>&gt; = [<span class="string">"TYO"</span>: <span class="string">"Tokyo"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]	<span class="comment">//等价于上一句</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> airports4 = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Sting</span>&gt;()	<span class="comment">//初始化为[Sting: String]空字典，指定了数据类型[String: String]，只能添加[String:String]数据，没有添加元素</span></div><div class="line"><span class="keyword">var</span> airports5 = [<span class="type">String</span>: <span class="type">String</span>]()		<span class="comment">//等价于上一句</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> airports6 = [:]	<span class="comment">//初始化为空字典，没有指定数据类型，通过添加数据自动判断</span></div><div class="line">airports6[<span class="number">2</span>] = <span class="number">3</span>	<span class="comment">//通过添加数据自动判断为[Int: Int]字典</span></div></pre></td></tr></table></figure></p>
<h2 id="数量-2"><a href="#数量-2" class="headerlink" title="数量"></a>数量</h2><ul>
<li>Dictionary.count：属性<code>count</code>表示字典<code>Dictionary</code>的元素个数。</li>
<li>Dictionary.isEmpty：属性<code>isEmpty</code>表示字典<code>Dictionary</code>的元素是否为0个，结果为<code>true</code>或<code>false</code>。</li>
</ul>
<h2 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h2><ul>
<li>Dictionary[key]：通过下标<code>[key]</code>访问字典<code>Dictionary</code>的键<code>key</code>对应的值，可修改。</li>
</ul>
<h2 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (airportCode, airportName) <span class="keyword">in</span> airports &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"\(airportCode): \(airportName)"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// TYO: Tokyo</span></div><div class="line"><span class="comment">// DUB: Dublin</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> airportCode <span class="keyword">in</span> airports.keys &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Airport code: \(airportCode)"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Airport code: TYO</span></div><div class="line"><span class="comment">// Airport code: DUB</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> airportName <span class="keyword">in</span> airports.values &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Airport name: \(airportName)"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Airport name: Tokyo</span></div><div class="line"><span class="comment">// Airport name: Dublin</span></div></pre></td></tr></table></figure>
<p><code>for-in</code>可便利字典，可便利键值对<code>(key, value)</code>，也可以通过属性<code>keys</code>或<code>values</code>只便利键值其中一项。<br>字典的属性<code>keys</code>和<code>values</code>返回数组。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> airportCodes = <span class="type">Array</span>(airports.keys)</div><div class="line"><span class="comment">// airportCodes is ["TYO", "DUB"]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> airportNames = <span class="type">Array</span>(airports.values)</div><div class="line"><span class="comment">// airportNames is ["Tokyo", "Dublin"]</span></div></pre></td></tr></table></figure></p>
<h2 id="添加-2"><a href="#添加-2" class="headerlink" title="添加"></a>添加</h2><ul>
<li>Dictionary[key] = value：更新字典<code>Dictionary</code>中键<code>key</code>对应的值，如果不存在，则将键值对<key, valye="">添加到字典<code>Dictionary</code>中。</key,></li>
<li>Dicitonary.updateValue(value, forkey: key)：更新字典<code>Dictionary</code>中键<code>key</code>对应的值，如果不存在，则将键值对<key, value="">添加到字典<code>Dictionary</code>。<br>注意：该方法返回<strong>原值</strong>，即执行<code>updateValue</code>方法之前键<code>key</code>对应的值，如果不存在，则返回<code>nil</code>。</key,></li>
</ul>
<h2 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h2><ul>
<li>Dictionary[key] = nil：删除字典<code>Dictionary</code>中键<code>key</code>对应的值。</li>
<li>Dictionary.removeValueForKey(key)：删除字典<code>Dictionary</code>中键<code>key</code>对应的值，返回删除的值，如果不存在，则返回<code>nil</code>。</li>
</ul>
<p>添加操作和删除操作返回值有可能为<code>nil</code>，都是可选类型，使用时需要进行判断是否有值。</p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍Swift的基础知识：数组（Array），集合（Set）和字符（Dictionary）。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="http://aidaiz.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://aidaiz.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础入门(2)：字符串和字符</title>
    <link href="http://aidaiz.com/swift_2/"/>
    <id>http://aidaiz.com/swift_2/</id>
    <published>2015-07-15T06:09:04.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍Swift的基础知识：字符串和字符。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/swift_2" target="_blank" rel="external">Swift基础入门(2)：字符串和字符</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#97;&#x69;&#100;&#x61;&#x69;&#x7a;&#121;&#121;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;">&#97;&#x69;&#100;&#x61;&#x69;&#x7a;&#121;&#121;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-07-15</a></strong></p>
<h2 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h2><h3 id="空字符串"><a href="#空字符串" class="headerlink" title="空字符串"></a>空字符串</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str1 = <span class="string">""</span></div><div class="line"><span class="keyword">var</span> str2 = <span class="type">String</span>()</div><div class="line"></div><div class="line"><span class="keyword">if</span> str1.isEmpty &#123;</div><div class="line">	<span class="comment">//空字符串</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两条语句等价，都表示空字符串。<br><code>String</code>的<code>isEmpty</code>属性表示<code>String</code>是否为空，结果为<code>Bool</code>值。</p>
<h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>在函数/方法中传递的是字符串的值，不会改变字符串本身。</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"Dog!"</span> &#123;</div><div class="line">    <span class="built_in">println</span>(character)</div><div class="line">&#125;</div><div class="line"><span class="comment">// D</span></div><div class="line"><span class="comment">// o</span></div><div class="line"><span class="comment">// g</span></div><div class="line"><span class="comment">// !</span></div></pre></td></tr></table></figure>
<p><code>for-in</code>：<code>for characte in &quot;Hello World!&quot;</code>将会遍历字符串<code>&quot;Hello World!&quot;</code>的每个字符，并用<code>character: Character</code>来表示。</p>
<h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p><code>count(String)</code>函数，得到字符串的字符数量。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ul>
<li>+, +=：连接字符串</li>
<li>String.append(Character)：将字符连接到字符串尾部。</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul>
<li>==：字符串相等</li>
<li>String1.hasPrefix(String2)：是否有特定前缀。如果<code>String1</code>包含前缀<code>String2</code>返回<code>true</code>，否则返回<code>false</code>。</li>
<li>String1.hasSuffix(String2)：是否有特定后缀。如果<code>String1</code>包含后缀<code>String2</code>返回<code>true</code>，否则返回<code>false</code>。</li>
</ul>
<h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> normal = <span class="string">"Could you help me, please?"</span></div><div class="line"><span class="keyword">let</span> shouty = normal.uppercaseString</div><div class="line"><span class="comment">// shouty 值为 "COULD YOU HELP ME, PLEASE?"</span></div><div class="line"><span class="keyword">let</span> whispered = normal.lowercaseString</div><div class="line"><span class="comment">// whispered 值为 "could you help me, please?"</span></div></pre></td></tr></table></figure>
<p>String.uppercaseString属性表示字符串的大写，String.lowercaseString属性表示字符串的小写。</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode字符用<code>\u{n}</code>表示，其中<code>n</code>为任意的一到八位十六进制数。</p>
<blockquote>
<p>String：<br>属性：<br>String.isEmpty<br>String.uppercaseString<br>String.lowercaseString<br>String.utf8<br>String.utf16<br>String.unicodeScalars<br>方法：<br>String.append()<br>String.hasPrefix()<br>String.hasSuffix()<br>count(String)</p>
</blockquote>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍Swift的基础知识：字符串和字符。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="http://aidaiz.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://aidaiz.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础入门(1)：常量变量，基本数据类型和基本运算符</title>
    <link href="http://aidaiz.com/swift_1/"/>
    <id>http://aidaiz.com/swift_1/</id>
    <published>2015-07-14T07:23:13.000Z</published>
    <updated>2017-05-08T16:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Swift是苹果公司于2014年推出的用于iOS，OS X和watchOS应用开发的新语言。<br>基于Swift 1.2。<br>本篇介绍Swift的基础知识：常量变量，基本数据类型和基本运算符。</p>
<a id="more"></a>
<p><strong>Title: <a href="https://aidaizyy.github.io/swift_1" target="_blank" rel="external">Swift基础入门(1)：常量变量，基本数据类型和基本运算符</a></strong><br><strong>Author: <a href="http://aidaizyy.github.io" target="_blank" rel="external">Yunyao Zhang(张云尧)</a></strong><br><strong>E-mail: <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x61;&#x69;&#x64;&#97;&#105;&#x7a;&#x79;&#x79;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;">&#x61;&#x69;&#x64;&#97;&#105;&#x7a;&#x79;&#x79;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;</a></strong><br><strong>Last Modified: <a href="http://aidaizyy.github.io" target="_blank" rel="external">2015-07-15</a></strong></p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Swift结合了C和Objectiv-C的特点，基于Cocoa和Cocoa Touch框架。<br>本文主要讲述Swift的基本语法。</p>
<h2 id="常量变量"><a href="#常量变量" class="headerlink" title="常量变量"></a>常量变量</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>常量变量命名不能包括数学符号，箭头，保留的Unicode码位，连线和制表符，不能以数字开头。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>声明常量使用<code>let</code>关键字，声明变量使用<code>var</code>关键字。<br>一般可省略数据类型，通过赋予的第一个值来自动确定数据类型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> maxNumber = <span class="number">20</span></div><div class="line"><span class="keyword">var</span> currentNumber = <span class="number">0</span>, item = <span class="number">0.1</span></div></pre></td></tr></table></figure></p>
<p>在swift中，语句结束不需要加分号。（添加分号也没有问题）<br>上面两句，声明了常量<code>maxNumber</code>，并赋值为20，这个值不能被改变。声明时可以不赋值，但之后只能赋值一次。<br>声明了变量<code>currentNumber</code>和<code>item</code>，并赋值为0和0.1，可赋值多次。<br>在一行中可声明多个常量或变量，用逗号隔开。<br><code>maxNumber</code>和<code>currentNumber</code>第一次赋值了整数，被确定为整数类型<code>Int</code>；<code>item</code>第一次赋值了小数，被确定为浮点数类型<code>Double</code>（未指定数据类型时，小数一定会被确定为<code>Double</code>而不是<code>Float</code>）。</p>
<blockquote>
<p>基本数据类型：</p>
<ul>
<li>Int</li>
<li>Double</li>
<li>Float</li>
<li>Bool</li>
<li>String</li>
<li>Character</li>
</ul>
</blockquote>
<p>声明常量变量时，也可以指定数据类型，通过在常量变量名称后接冒号再接数据类型名称来实现。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currentNumer: <span class="type">Double</span> = <span class="number">5</span></div><div class="line"><span class="built_in">println</span>(currentNumber)	<span class="comment">//输出currentNumber的值</span></div></pre></td></tr></table></figure></p>
<p>上面两句输出结果为<code>5.0</code>，因为<code>currentNumber</code>指定为<code>Double</code>类型，即使给它赋值了整数5。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><code>println</code>和<code>print</code>函数都是输出函数，区别在于前者在输出末尾加上了换行符。</p>
<p>输出常量变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currentNumer: <span class="type">Double</span> = <span class="number">5</span></div><div class="line"><span class="built_in">println</span>(<span class="string">"The current number is \(currentNumber)"</span>)</div></pre></td></tr></table></figure></p>
<p>上面两句输出结果为<code>The current number is 0.5</code>。<br>通过<code>\(常量变量)</code>将常量变量转换为字符串并在<code>println</code>语句中输出。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>和C语言类似，注释分为单行注释<code>//</code>和多行注释<code>/*  */</code><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> single	<span class="comment">//单行注释</span></div><div class="line"></div><div class="line"><span class="comment">/* 多行注释 */</span></div></pre></td></tr></table></figure></p>
<p>不一样的地方在于，swift的<code>/* */</code>可以嵌套。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>整数分为<code>Int8</code>，<code>UInt8</code>，<code>Int16</code>，<code>UInt16</code>，<code>Int32</code>，<code>UInt32</code>，<code>Int64</code>，<code>UInt64</code>，分别对应8，16，32，64位的有符号整数类型和无符号整数类型。<br>一般<code>Int</code>指<code>Int32</code>（32位电脑）或<code>Int64</code>（64位电脑）。<br>整数类型都有<code>min</code>和<code>max</code>两个方法。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="type">Int</span>.<span class="built_in">max</span></div><div class="line"><span class="built_in">println</span>(tmp)</div></pre></td></tr></table></figure></p>
<p>结果为<code>9223372036854775807</code>（64位电脑）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> decimalInteger = <span class="number">17</span>		<span class="comment">//十进制表示17</span></div><div class="line"><span class="keyword">let</span> binaryInteger = <span class="number">0b1001</span>	<span class="comment">//二进制表示17</span></div><div class="line"><span class="keyword">let</span> octalInteger = <span class="number">0o21</span>		<span class="comment">//八进制表示17</span></div><div class="line"><span class="keyword">let</span> hexadecimalInteger = <span class="number">0x11</span>	<span class="comment">//十六进制表示17</span></div></pre></td></tr></table></figure>
<p>二进制，八进制和十六进制分别加前缀<code>0b</code>，<code>0o</code>，<code>0x</code>表示。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul>
<li>Double：64位浮点数，至少15位数字</li>
<li>Float：32位浮点数，最少6位数字</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> decimalDouble = <span class="number">12.1875</span>	<span class="comment">//十进制表示12.1875</span></div><div class="line"><span class="keyword">let</span> exponentDouble = <span class="number">1.21875e1</span>	<span class="comment">//十进制指数表示12.1875</span></div><div class="line"><span class="keyword">let</span> hexadecimalDouble = <span class="number">0xC.3p0</span>	<span class="comment">//十六进制指数表示12.1875</span></div></pre></td></tr></table></figure>
<p>浮点数字面量可以用十进制和十六进制表示，指数分别用<code>e</code>和<code>p</code>表示。</p>
<p>数值型字面量都可以加0或_，不影响数值，比如<code>000_1_000.000_000_1</code>等于<code>1000.0000001</code>。</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>Bool</code>有两个值<code>true</code>和<code>false</code>。</p>
<h3 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h3><blockquote>
<p>可选类型（_optionals)用来表示值可能丢失的情况：</p>
<ul>
<li>有值且等于x</li>
<li>没有值</li>
</ul>
</blockquote>
<ul>
<li><p>有无值判断<br>可以通过条件语句判断，<code>if optional != nil</code>，结果为<code>ture</code>即表示有值，否则表示无值。</p>
</li>
<li><p>强制解析<br>在名字后面加<code>!</code>强制获取可选类型的值，但必须在有值的情况下，否则会报错，<code>optional!</code>。</p>
</li>
<li><p>可选绑定</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> optionalValue: <span class="type">Int</span>? = <span class="number">123</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualValue = optionalValue &#123;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>Int?</code>在数据类型后面加<code>?</code>表示包含该数据类型的可选类型，<code>optionalValue</code>表示包含<code>123</code>的可选类型，如果包含值，则赋值给<code>actualValue</code>，并返回<code>true</code>，否则返回<code>false</code>。</p>
<ul>
<li>无值：nil<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> optionalInt: <span class="type">Int</span>? = <span class="number">123</span></div><div class="line">optionalInt = <span class="literal">nil</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> optionalStr: <span class="type">String</span>?</div></pre></td></tr></table></figure>
</li>
</ul>
<p>可选类型可以被赋值为nil，即表示无值，这表示一个确定的值。<br>如果可选类型声明时没有赋值，则自动赋值为nil。</p>
<ul>
<li>隐式解析<br>声明时将数据类型后面的<code>?</code>改为<code>!</code>，表示一个隐式解析可选类型，即每次自动解析，使用时可直接用常量变量名称。</li>
</ul>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>可选类型无值可能会影响程序运行，在某些特定情况下，需要终止程序，我们使用断言。<br>断言类似于条件判断语句，不同点在于，结果为<code>false</code>时直接终止程序。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> age = -<span class="number">3</span></div><div class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>, <span class="string">"age cannot be less than zero"</span>)</div></pre></td></tr></table></figure></p>
<p><code>assert</code>的第二个参数描述信息可以省略。</p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组（<em>tuples</em>）把多个数据类型组合成一个复合的数据类型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> httpStatus1 = (statusCode: <span class="number">200</span>, description: <span class="string">"OK"</span>)</div><div class="line"><span class="built_in">println</span>(httpStatus1.statusCode, httpStatus1.description)</div><div class="line"><span class="comment">//输出“200OK”</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> httpStatus2 = (<span class="number">200</span>, <span class="string">"OK"</span>)</div><div class="line"><span class="built_in">println</span>(httpStatus2.<span class="number">0</span>, httpStatus2.<span class="number">1</span>)</div><div class="line"><span class="comment">//输出“200OK”</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> (statusCode, statusMessage) = httpStatus2</div><div class="line"><span class="built_in">println</span>(statusCode, statusMessage)</div><div class="line"><span class="comment">//输出“200OK”</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> (statusCode, <span class="number">_</span>) = httpStatus2</div><div class="line"><span class="built_in">println</span>(statusCode)</div><div class="line"><span class="comment">//输出“200”</span></div></pre></td></tr></table></figure></p>
<p>元组用括号<code>(Int, String)</code>表示一个整数和一个字符串组合，可以给元组的单个元素命名，比如第1行的<code>statusCode</code>和<code>description</code>，调用时直接用<code>httpStatus1.statusCode</code>和<code>httpStatus2.description</code>表示；如果不命名，则用<code>.0</code>和<code>.1</code>表示。<br>也可以把元组内容分解，比如第9行，分别用<code>statusCode</code>和<code>statusMessage</code>存储元组<code>httpStatus2</code>对应的元素。分解过程中忽略的部分可用<code>_</code>表示，比如第13行，只使<code>statusCode</code>存储元组<code>httpStatus2</code>的第一个元素，忽略第二个元素。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typealias</span> tmpType = <span class="type">Int</span></div><div class="line"><span class="keyword">let</span> tmpValue: tmpType = <span class="number">4</span></div></pre></td></tr></table></figure>
<p>通过<code>typealias</code>关键字，给现有的数据类型再起一个新的名字，可替代使用。<br>常量<code>tmpValue</code>的数据类型就是<code>Int</code>。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li><p>Int，Double，Float：<br><code>Int16</code>与<code>Int8</code>不能直接相加，需要通过<code>Int16(Int8)</code>转换。<br>同样，<code>Double</code>与<code>Int</code>也不能相加，也需要通过<code>Double(Int)</code>转换，如果只需要整数部分，也可以通过<code>Int(Double)</code>转换。</p>
</li>
<li><p>String，Int：<br>String-&gt;Int：<code>String.toInt()</code>函数可以把<code>String</code>转换成可选类型<code>Int?</code>，因为<code>String</code>中不一定能转换成<code>Int</code>，所以得到可选类型。<br>Int-&gt;String：<code>String(Int)</code>函数可以把<code>Int</code>转换成<code>String</code>。</p>
</li>
</ul>
<h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><h3 id="普通运算符"><a href="#普通运算符" class="headerlink" title="普通运算符"></a>普通运算符</h3><p>大部分基本运算符和主流语言一致：</p>
<ul>
<li>+：加</li>
<li>-：减</li>
<li>*：乘</li>
<li>/：除</li>
<li>=：赋值<pre><code>- 不返回值，将`if a == b`误写成`if a = b`会出现编译错误。
- 元组赋值，`let (x, y) = (1, 2)`，表示`x = 1`且`y = 2`。
</code></pre></li>
<li>%：求余<pre><code>- 除了整数，也可以对浮点数求余，`8 % 2.5`等于`Double`值`0.5`。
</code></pre></li>
<li>++：自增</li>
<li>–：自减<pre><code>- 除了整数，浮点数也可以自增和自减。
</code></pre></li>
<li>-：负号</li>
<li>+：正号</li>
<li>+=, -=, *=, /=, %=：复合赋值</li>
<li>==：等于</li>
<li>!=: 不等于</li>
<li>>, &lt;, &gt;=, &lt;=：比较运算符</li>
<li>===, !===：是否引用同一个对象实例</li>
<li>? : ：三目运算符</li>
<li>&amp;&amp;：与</li>
<li>||：或</li>
<li>!：非</li>
<li>()：括号，确定运算先后顺序</li>
</ul>
<h3 id="空合运算符（Nil-Coalescing-Operator）"><a href="#空合运算符（Nil-Coalescing-Operator）" class="headerlink" title="空合运算符（Nil Coalescing Operator）"></a>空合运算符（Nil Coalescing Operator）</h3><p><code>a ?? b</code>：其中<code>a</code>必须是可选（<em>Optional</em>）类型，<code>b</code>的类型与a存储的值的类型一致。<br>如果a包含一个值，就返回<code>a</code>包含的值；否则返回默认值<code>b</code>，等同于<code>a != nil ? a! : b</code>。</p>
<h3 id="区间运算符（Range-Operator）"><a href="#区间运算符（Range-Operator）" class="headerlink" title="区间运算符（Range Operator）"></a>区间运算符（Range Operator）</h3><p><code>a..&lt;b</code>，闭区间运算符，表示<code>a</code>到<code>b</code>的区间，包含<code>a</code>，不包含<code>b</code>；<br><code>a...b</code>，半开区间运算符，表示<code>a</code>到<code>b</code>的区间，包含<code>a</code>和<code>b</code>。</p>
<p><strong> 转载请注明原作者和出处。</strong></p>
<blockquote>
<p>如果觉得这篇文章对您有帮助或启发，请随意打赏~</p>
<p> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode01.jpg" width="250" align="left"> <img src="http://7xivk7.com1.z0.glb.clouddn.com/paycode02.jpg" width="250" align="left"> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift是苹果公司于2014年推出的用于iOS，OS X和watchOS应用开发的新语言。&lt;br&gt;基于Swift 1.2。&lt;br&gt;本篇介绍Swift的基础知识：常量变量，基本数据类型和基本运算符。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="http://aidaiz.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://aidaiz.com/tags/swift/"/>
    
  </entry>
  
</feed>
